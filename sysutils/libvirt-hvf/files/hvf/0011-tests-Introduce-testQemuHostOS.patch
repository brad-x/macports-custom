From: Andrea Bolognani <abologna@redhat.com>
Subject: [libvirt PATCH v4 11/19] tests: Introduce testQemuHostOS
Date: Fri,  7 Jan 2022 10:47:38 +0100
Content-Type: text/plain; charset="utf-8"

This new enumeration provides a way to specify the host OS
that a specific test case expects. The default is Linux, which
has been the implicit host OS until now; when Linux is selected
as the host OS, KVM support is advertised in capabilies data
exposed to test cases.

This commit doesn't result in any functional change, and simply
sets the stage for introducing macOS host OS support later.

Signed-off-by: Andrea Bolognani <abologna@redhat.com>
---
 tests/testutilsqemu.c | 87 +++++++++++++++++++++++++++----------------
 tests/testutilsqemu.h |  4 ++
 2 files changed, 58 insertions(+), 33 deletions(-)

diff --git tests/testutilsqemu.c tests/testutilsqemu.c
index cb665e501b..b9835782da 100644
--- tests/testutilsqemu.c
+++ tests/testutilsqemu.c
@@ -160,7 +160,8 @@ virHostCPUX86GetCPUID(uint32_t leaf,
 
 static int
 testQemuAddGuest(virCaps *caps,
-                 virArch arch)
+                 virArch arch,
+                 testQemuHostOS hostOS)
 {
     size_t nmachines;
     virCapsGuestMachine **machines = NULL;
@@ -193,16 +194,18 @@ testQemuAddGuest(virCaps *caps,
     virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_QEMU,
                                   NULL, NULL, 0, NULL);
 
-    if (kvm_machines[emu_arch] != NULL) {
-        nmachines = g_strv_length((char **)kvm_machines[emu_arch]);
-        machines = virCapabilitiesAllocMachines(kvm_machines[emu_arch],
-                                                nmachines);
-        if (machines == NULL)
-            goto error;
-
-        virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_KVM,
-                                      qemu_emulators[emu_arch],
-                                      NULL, nmachines, machines);
+    if (hostOS == HOST_OS_LINUX) {
+        if (kvm_machines[emu_arch] != NULL) {
+            nmachines = g_strv_length((char **)kvm_machines[emu_arch]);
+            machines = virCapabilitiesAllocMachines(kvm_machines[emu_arch],
+                                                    nmachines);
+            if (machines == NULL)
+                goto error;
+
+            virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_KVM,
+                                          qemu_emulators[emu_arch],
+                                          NULL, nmachines, machines);
+        }
     }
 
     return 0;
@@ -213,7 +216,8 @@ testQemuAddGuest(virCaps *caps,
 }
 
 
-virCaps *testQemuCapsInit(void)
+static virCaps*
+testQemuCapsInitImpl(testQemuHostOS hostOS)
 {
     virCaps *caps;
     size_t i;
@@ -233,7 +237,7 @@ virCaps *testQemuCapsInit(void)
         goto cleanup;
 
     for (i = 0; i < VIR_ARCH_LAST; i++) {
-        if (testQemuAddGuest(caps, i) < 0)
+        if (testQemuAddGuest(caps, i, hostOS) < 0)
             goto cleanup;
     }
 
@@ -255,6 +259,12 @@ virCaps *testQemuCapsInit(void)
     return NULL;
 }
 
+virCaps*
+testQemuCapsInit(void)
+{
+    return testQemuCapsInitImpl(HOST_OS_LINUX);
+}
+
 
 void
 qemuTestSetHostArch(virQEMUDriver *driver,
@@ -335,10 +345,10 @@ void qemuTestDriverFree(virQEMUDriver *driver)
     virCPUDefFree(cpuPower9);
 }
 
-
 static void
 qemuTestCapsPopulateFakeMachines(virQEMUCaps *caps,
-                                 virArch arch)
+                                 virArch arch,
+                                 testQemuHostOS hostOS)
 {
     size_t i;
     const char *defaultRAMid = NULL;
@@ -366,20 +376,22 @@ qemuTestCapsPopulateFakeMachines(virQEMUCaps *caps,
         virQEMUCapsSet(caps, QEMU_CAPS_TCG);
     }
 
-    if (kvm_machines[arch] != NULL) {
-        for (i = 0; kvm_machines[arch][i] != NULL; i++) {
-            virQEMUCapsAddMachine(caps,
-                                  VIR_DOMAIN_VIRT_KVM,
-                                  kvm_machines[arch][i],
-                                  NULL,
-                                  NULL,
-                                  0,
-                                  false,
-                                  false,
-                                  true,
-                                  defaultRAMid,
-                                  false);
-            virQEMUCapsSet(caps, QEMU_CAPS_KVM);
+    if (hostOS == HOST_OS_LINUX) {
+        if (kvm_machines[arch] != NULL) {
+            for (i = 0; kvm_machines[arch][i] != NULL; i++) {
+                virQEMUCapsAddMachine(caps,
+                                      VIR_DOMAIN_VIRT_KVM,
+                                      kvm_machines[arch][i],
+                                      NULL,
+                                      NULL,
+                                      0,
+                                      false,
+                                      false,
+                                      true,
+                                      defaultRAMid,
+                                      false);
+                virQEMUCapsSet(caps, QEMU_CAPS_KVM);
+            }
         }
     }
 }
@@ -399,8 +411,10 @@ qemuTestCapsCacheInsertData(virFileCache *cache,
 }
 
 
-int qemuTestCapsCacheInsert(virFileCache *cache,
-                            virQEMUCaps *caps)
+static int
+qemuTestCapsCacheInsertImpl(virFileCache *cache,
+                            virQEMUCaps *caps,
+                            testQemuHostOS hostOS)
 {
     size_t i;
 
@@ -425,7 +439,7 @@ int qemuTestCapsCacheInsert(virFileCache *cache,
                 if (!(copyCaps = effCaps = virQEMUCapsNewCopy(caps)))
                     return -1;
 
-                qemuTestCapsPopulateFakeMachines(copyCaps, arch);
+                qemuTestCapsPopulateFakeMachines(copyCaps, arch, hostOS);
             }
 
             if (qemuTestCapsCacheInsertData(cache, qemu_emulators[arch], effCaps) < 0)
@@ -460,7 +474,7 @@ int qemuTestCapsCacheInsert(virFileCache *cache,
             if (!tmp)
                 return -1;
 
-            qemuTestCapsPopulateFakeMachines(tmp, i);
+            qemuTestCapsPopulateFakeMachines(tmp, i, hostOS);
 
             if (qemuTestCapsCacheInsertData(cache, qemu_emulators[i], tmp) < 0)
                 return -1;
@@ -470,6 +484,13 @@ int qemuTestCapsCacheInsert(virFileCache *cache,
     return 0;
 }
 
+int
+qemuTestCapsCacheInsert(virFileCache *cache,
+                        virQEMUCaps *caps)
+{
+    return qemuTestCapsCacheInsertImpl(cache, caps, HOST_OS_LINUX);
+}
+
 
 # define STATEDIRTEMPLATE abs_builddir "/qemustatedir-XXXXXX"
 # define CONFIGDIRTEMPLATE abs_builddir "/qemuconfigdir-XXXXXX"
diff --git tests/testutilsqemu.h tests/testutilsqemu.h
index d59fa53239..a8de6eb52b 100644
--- tests/testutilsqemu.h
+++ tests/testutilsqemu.h
@@ -33,6 +33,10 @@ enum {
     GIC_BOTH,
 };
 
+typedef enum {
+    HOST_OS_LINUX = 0,
+} testQemuHostOS;
+
 typedef enum {
     ARG_QEMU_CAPS = QEMU_CAPS_LAST + 1,
     ARG_GIC,
-- 
2.31.1

