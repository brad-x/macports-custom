diff -ru --un qemu-7.2.0/accel/tcg/cpu-exec.c qemu-utm-7.2.0/accel/tcg/cpu-exec.c
--- qemu-7.2.0/accel/tcg/cpu-exec.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/accel/tcg/cpu-exec.c	2022-12-26 13:45:03
@@ -27,6 +27,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #include "qemu/atomic.h"
 #include "qemu/compiler.h"
 #include "qemu/timer.h"
diff -ru --un qemu-7.2.0/accel/tcg/tb-maint.c qemu-utm-7.2.0/accel/tcg/tb-maint.c
--- qemu-7.2.0/accel/tcg/tb-maint.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/accel/tcg/tb-maint.c	2022-12-26 13:45:03
@@ -24,6 +24,7 @@
 #include "exec/translate-all.h"
 #include "sysemu/tcg.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #include "tb-hash.h"
 #include "tb-context.h"
 #include "internal.h"
diff -ru --un qemu-7.2.0/accel/tcg/tcg-accel-ops.c qemu-utm-7.2.0/accel/tcg/tcg-accel-ops.c
--- qemu-7.2.0/accel/tcg/tcg-accel-ops.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/accel/tcg/tcg-accel-ops.c	2022-12-26 13:45:03
@@ -47,6 +47,11 @@
     uint32_t cflags = cpu->cluster_index << CF_CLUSTER_SHIFT;
     cflags |= parallel ? CF_PARALLEL : 0;
     cflags |= icount_enabled() ? CF_USE_ICOUNT : 0;
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+    // GOTO_PTR is too complex to emit a simple gadget for.
+    // We'll let C handle it, since the overhead is similar.
+    cflags |= CF_NO_GOTO_PTR;
+#endif
     cpu->tcg_cflags = cflags;
 }
 
diff -ru --un qemu-7.2.0/accel/tcg/translate-all.c qemu-utm-7.2.0/accel/tcg/translate-all.c
--- qemu-7.2.0/accel/tcg/translate-all.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/accel/tcg/translate-all.c	2022-12-26 13:45:03
@@ -24,6 +24,7 @@
 #include "disas/disas.h"
 #include "exec/exec-all.h"
 #include "tcg/tcg.h"
+#include "tcg/tcg-apple-jit.h"
 #if defined(CONFIG_USER_ONLY)
 #include "qemu.h"
 #if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
diff -ru --un qemu-7.2.0/audio/audio.c qemu-utm-7.2.0/audio/audio.c
--- qemu-7.2.0/audio/audio.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/audio/audio.c	2022-12-26 13:45:03
@@ -1409,12 +1409,21 @@
 #endif
 }
 
+void audio_generic_initialize_buffer_in(HWVoiceIn *hw)
+{
+    if (hw->buf_emul) {
+        g_free(hw->buf_emul);
+    }
+
+    hw->size_emul = hw->samples * hw->info.bytes_per_frame;
+    hw->buf_emul = g_malloc(hw->size_emul);
+    hw->pos_emul = hw->pending_emul = 0;
+}
+
 void audio_generic_run_buffer_in(HWVoiceIn *hw)
 {
     if (unlikely(!hw->buf_emul)) {
-        hw->size_emul = hw->samples * hw->info.bytes_per_frame;
-        hw->buf_emul = g_malloc(hw->size_emul);
-        hw->pos_emul = hw->pending_emul = 0;
+        audio_generic_initialize_buffer_in(hw);
     }
 
     while (hw->pending_emul < hw->size_emul) {
@@ -1448,6 +1457,17 @@
     hw->pending_emul -= size;
 }
 
+void audio_generic_initialize_buffer_out(HWVoiceOut *hw)
+{
+    if (hw->buf_emul) {
+        g_free(hw->buf_emul);
+    }
+
+    hw->size_emul = hw->samples * hw->info.bytes_per_frame;
+    hw->buf_emul = g_malloc(hw->size_emul);
+    hw->pos_emul = hw->pending_emul = 0;
+}
+
 size_t audio_generic_buffer_get_free(HWVoiceOut *hw)
 {
     if (hw->buf_emul) {
@@ -1479,9 +1499,7 @@
 void *audio_generic_get_buffer_out(HWVoiceOut *hw, size_t *size)
 {
     if (unlikely(!hw->buf_emul)) {
-        hw->size_emul = hw->samples * hw->info.bytes_per_frame;
-        hw->buf_emul = g_malloc(hw->size_emul);
-        hw->pos_emul = hw->pending_emul = 0;
+        audio_generic_initialize_buffer_out(hw);
     }
 
     *size = MIN(hw->size_emul - hw->pending_emul,
diff -ru --un qemu-7.2.0/audio/audio_int.h qemu-utm-7.2.0/audio/audio_int.h
--- qemu-7.2.0/audio/audio_int.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/audio/audio_int.h	2022-12-26 13:45:03
@@ -190,9 +190,11 @@
     void   (*volume_in)(HWVoiceIn *hw, Volume *vol);
 };
 
+void audio_generic_initialize_buffer_in(HWVoiceIn *hw);
 void audio_generic_run_buffer_in(HWVoiceIn *hw);
 void *audio_generic_get_buffer_in(HWVoiceIn *hw, size_t *size);
 void audio_generic_put_buffer_in(HWVoiceIn *hw, void *buf, size_t size);
+void audio_generic_initialize_buffer_out(HWVoiceOut *hw);
 void audio_generic_run_buffer_out(HWVoiceOut *hw);
 size_t audio_generic_buffer_get_free(HWVoiceOut *hw);
 void *audio_generic_get_buffer_out(HWVoiceOut *hw, size_t *size);
diff -ru --un qemu-7.2.0/audio/coreaudio.m qemu-utm-7.2.0/audio/coreaudio.m
--- qemu-7.2.0/audio/coreaudio.m	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/audio/coreaudio.m	2022-12-26 13:45:03
@@ -360,7 +360,10 @@
 static OSStatus init_out_device(coreaudioVoiceOut *core)
 {
     OSStatus status;
+    AudioDeviceID deviceID;
     AudioValueRange frameRange;
+    UInt32 audioDevicePropertyBufferFrameSize;
+    AudioDeviceIOProcID ioprocid;
 
     AudioStreamBasicDescription streamBasicDescription = {
         .mBitsPerChannel = core->hw.info.bits,
@@ -373,20 +376,19 @@
         .mSampleRate = core->hw.info.freq
     };
 
-    status = coreaudio_get_voice(&core->outputDeviceID);
+    status = coreaudio_get_voice(&deviceID);
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
                                    "Could not get default output Device\n");
         return status;
     }
-    if (core->outputDeviceID == kAudioDeviceUnknown) {
+    if (deviceID == kAudioDeviceUnknown) {
         dolog ("Could not initialize playback - Unknown Audiodevice\n");
         return status;
     }
 
     /* get minimum and maximum buffer frame sizes */
-    status = coreaudio_get_framesizerange(core->outputDeviceID,
-                                          &frameRange);
+    status = coreaudio_get_framesizerange(deviceID, &frameRange);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -397,31 +399,31 @@
     }
 
     if (frameRange.mMinimum > core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;
+        audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMinimum;
         dolog ("warning: Upsizing Buffer Frames to %f\n", frameRange.mMinimum);
     } else if (frameRange.mMaximum < core->frameSizeSetting) {
-        core->audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;
+        audioDevicePropertyBufferFrameSize = (UInt32) frameRange.mMaximum;
         dolog ("warning: Downsizing Buffer Frames to %f\n", frameRange.mMaximum);
     } else {
-        core->audioDevicePropertyBufferFrameSize = core->frameSizeSetting;
+        audioDevicePropertyBufferFrameSize = core->frameSizeSetting;
     }
 
     /* set Buffer Frame Size */
-    status = coreaudio_set_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_set_framesize(deviceID,
+                                     &audioDevicePropertyBufferFrameSize);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
     if (status != kAudioHardwareNoError) {
         coreaudio_playback_logerr (status,
                                     "Could not set device buffer frame size %" PRIu32 "\n",
-                                    (uint32_t)core->audioDevicePropertyBufferFrameSize);
+                                    (uint32_t)audioDevicePropertyBufferFrameSize);
         return status;
     }
 
     /* get Buffer Frame Size */
-    status = coreaudio_get_framesize(core->outputDeviceID,
-                                     &core->audioDevicePropertyBufferFrameSize);
+    status = coreaudio_get_framesize(deviceID,
+                                     &audioDevicePropertyBufferFrameSize);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -430,11 +432,9 @@
                                     "Could not get device buffer frame size\n");
         return status;
     }
-    core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
 
     /* set Samplerate */
-    status = coreaudio_set_streamformat(core->outputDeviceID,
-                                        &streamBasicDescription);
+    status = coreaudio_set_streamformat(deviceID, &streamBasicDescription);
     if (status == kAudioHardwareBadObjectError) {
         return 0;
     }
@@ -442,7 +442,6 @@
         coreaudio_playback_logerr (status,
                                    "Could not set samplerate %lf\n",
                                    streamBasicDescription.mSampleRate);
-        core->outputDeviceID = kAudioDeviceUnknown;
         return status;
     }
 
@@ -456,20 +455,25 @@
      * Therefore, the specified callback must be designed to avoid a deadlock
      * with the callers of AudioObjectGetPropertyData.
      */
-    core->ioprocid = NULL;
-    status = AudioDeviceCreateIOProcID(core->outputDeviceID,
+    ioprocid = NULL;
+    status = AudioDeviceCreateIOProcID(deviceID,
                                        audioDeviceIOProc,
                                        &core->hw,
-                                       &core->ioprocid);
+                                       &ioprocid);
     if (status == kAudioHardwareBadDeviceError) {
         return 0;
     }
-    if (status != kAudioHardwareNoError || core->ioprocid == NULL) {
+    if (status != kAudioHardwareNoError || ioprocid == NULL) {
         coreaudio_playback_logerr (status, "Could not set IOProc\n");
-        core->outputDeviceID = kAudioDeviceUnknown;
         return status;
     }
 
+    core->outputDeviceID = deviceID;
+    core->audioDevicePropertyBufferFrameSize = audioDevicePropertyBufferFrameSize;
+    core->hw.samples = core->bufferCount * core->audioDevicePropertyBufferFrameSize;
+    audio_generic_initialize_buffer_out(&core->hw);
+    core->ioprocid = ioprocid;
+
     return 0;
 }
 
@@ -553,7 +557,9 @@
         fini_out_device(core);
     }
 
-    if (!init_out_device(core)) {
+    init_out_device(core);
+
+    if (core->outputDeviceID) {
         update_device_playback_state(core);
     }
 
diff -ru --un qemu-7.2.0/block/file-posix.c qemu-utm-7.2.0/block/file-posix.c
--- qemu-7.2.0/block/file-posix.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/block/file-posix.c	2022-12-26 13:45:03
@@ -43,10 +43,10 @@
 
 #if defined(__APPLE__) && (__MACH__)
 #include <sys/ioctl.h>
-#if defined(HAVE_HOST_BLOCK_DEVICE)
-#include <paths.h>
 #include <sys/param.h>
 #include <sys/mount.h>
+#if defined(HAVE_HOST_BLOCK_DEVICE)
+#include <paths.h>
 #include <IOKit/IOKitLib.h>
 #include <IOKit/IOBSD.h>
 #include <IOKit/storage/IOMediaBSDClient.h>
@@ -130,6 +130,14 @@
 #define RAW_LOCK_PERM_BASE             100
 #define RAW_LOCK_SHARED_BASE           200
 
+/*
+ * qemu_lock_fd_test always returns 0 when fd is not open for writing and
+ * exclusive is true on macOS 11.3.1.
+ */
+#ifdef __APPLE__
+#define RAW_LOCK_WRITES
+#endif
+
 typedef struct BDRVRawState {
     int fd;
     bool use_lock;
@@ -673,7 +681,11 @@
                                                false);
 
     s->open_flags = open_flags;
+#ifdef RAW_LOCK_WRITES
+    raw_parse_flags(bdrv_flags, &s->open_flags, s->use_lock);
+#else
     raw_parse_flags(bdrv_flags, &s->open_flags, false);
+#endif
 
     s->fd = -1;
     fd = qemu_open(filename, s->open_flags, errp);
@@ -1038,6 +1050,11 @@
     bool has_writers = perm &
         (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED | BLK_PERM_RESIZE);
     int fcntl_flags = O_APPEND | O_NONBLOCK;
+#ifdef RAW_LOCK_WRITES
+    if (s->use_lock) {
+        has_writers = true;
+    }
+#endif
 #ifdef O_NOATIME
     fcntl_flags |= O_NOATIME;
 #endif
diff -ru --un qemu-7.2.0/configure qemu-utm-7.2.0/configure
--- qemu-7.2.0/configure	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/configure	2022-12-26 13:45:03
@@ -290,6 +290,7 @@
 ninja=""
 bindir="bin"
 skip_meson=no
+shared_lib="no"
 vfio_user_server="disabled"
 
 # The following Meson options are handled manually (still they
@@ -896,6 +897,12 @@
   ;;
   --enable-jemalloc) meson_option_parse --enable-malloc=jemalloc jemalloc
   ;;
+  --enable-shared-lib)
+      shared_lib="yes"
+      plugins="no"
+  ;;
+  --disable-shared-lib) shared_lib="no"
+  ;;
   # everything else has the same name in configure and meson
   --*) meson_option_parse "$opt" "$optarg"
   ;;
@@ -907,6 +914,10 @@
     error_exit "Can't enable plugins on non-TCG builds"
 fi
 
+if test "$plugins" = "yes" -a "$shared_lib" = "yes"; then
+    error_exit "Can't enable plugins on shared library builds"
+fi
+
 case $git_submodules_action in
     update|validate)
         if test ! -e "$source_path/.git"; then
@@ -1031,7 +1042,7 @@
   --disable-stack-protector disable compiler-provided stack protection
   --cpu=CPU                Build for host CPU [$cpu]
   --with-coroutine=BACKEND coroutine backend. Supported options:
-                           ucontext, sigaltstack, windows
+                           ucontext, libucontext, sigaltstack, windows
   --enable-plugins
                            enable plugins via shared library loading
   --disable-containers     don't use containers for cross-building
@@ -1595,12 +1606,26 @@
       error_exit "only the 'windows' coroutine backend is valid for Windows"
     fi
     ;;
+  libucontext)
+  ;;
   *)
     error_exit "unknown coroutine backend $coroutine"
     ;;
   esac
 fi
 
+case $coroutine in
+libucontext)
+  git_submodules="${git_submodules} subprojects/libucontext"
+  coroutine_impl=ucontext
+  libucontext="enabled"
+  ;;
+*)
+  coroutine_impl=$coroutine
+  libucontext="disabled"
+  ;;
+esac
+
 ##################################################
 # SafeStack
 
@@ -2378,7 +2403,7 @@
   echo "CONFIG_BSD=y" >> $config_host_mak
 fi
 
-echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
+echo "CONFIG_COROUTINE_BACKEND=$coroutine_impl" >> $config_host_mak
 
 if test "$have_asan_iface_fiber" = "yes" ; then
     echo "CONFIG_ASAN_IFACE_FIBER=y" >> $config_host_mak
@@ -2392,6 +2417,10 @@
     echo "CONFIG_PLUGIN=y" >> $config_host_mak
 fi
 
+if test "$shared_lib" = "yes" ; then
+  echo "CONFIG_SHARED_LIBRARY_BUILD=y" >> $config_host_mak
+fi
+
 if test -n "$gdb_bin"; then
     gdb_version=$($gdb_bin --version | head -n 1)
     if version_ge ${gdb_version##* } 9.1; then
@@ -2558,7 +2587,11 @@
   if has $sdl2_config; then
     echo "sdl2-config = [$(meson_quote $sdl2_config)]" >> $cross
   fi
-  echo "strip = [$(meson_quote $strip)]" >> $cross
+  if test "$shared_lib" = "yes"; then
+    echo "strip = [$(meson_quote $strip), '-x']" >> $cross
+  else
+    echo "strip = [$(meson_quote $strip)]" >> $cross
+  fi
   echo "widl = [$(meson_quote $widl)]" >> $cross
   echo "windres = [$(meson_quote $windres)]" >> $cross
   if test "$cross_compile" = "yes"; then
diff -ru --un qemu-7.2.0/contrib/vhost-user-gpu/virgl.c qemu-utm-7.2.0/contrib/vhost-user-gpu/virgl.c
--- qemu-7.2.0/contrib/vhost-user-gpu/virgl.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/contrib/vhost-user-gpu/virgl.c	2022-12-26 13:45:03
@@ -323,7 +323,7 @@
                       struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_set_scanout ss;
-    struct virgl_renderer_resource_info info;
+    struct virgl_renderer_texture_info info;
     int ret;
 
     VUGPU_FILL_CMD(ss);
@@ -338,7 +338,7 @@
     memset(&info, 0, sizeof(info));
 
     if (ss.resource_id && ss.r.width && ss.r.height) {
-        ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
+        ret = virgl_renderer_borrow_texture_for_scanout(ss.resource_id, &info);
         if (ret == -1) {
             g_critical("%s: illegal resource specified %d\n",
                        __func__, ss.resource_id);
diff -ru --un qemu-7.2.0/disas.c qemu-utm-7.2.0/disas.c
--- qemu-7.2.0/disas.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/disas.c	2022-12-26 13:45:03
@@ -151,6 +151,8 @@
 #endif
 #if defined(CONFIG_TCG_INTERPRETER)
     s->info.print_insn = print_insn_tci;
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+    s->info.print_insn = print_insn_tcti;
 #elif defined(__i386__)
     s->info.mach = bfd_mach_i386_i386;
     s->info.cap_arch = CS_ARCH_X86;
diff -ru --un qemu-7.2.0/hw/arm/virt.c qemu-utm-7.2.0/hw/arm/virt.c
--- qemu-7.2.0/hw/arm/virt.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/arm/virt.c	2022-12-26 13:45:03
@@ -1713,7 +1713,11 @@
      * irrespective of the underlying capabilities of the HW.
      */
     if (!vms->highmem) {
+#ifdef CONFIG_DARWIN
+        pa_bits = 36;
+#else
         pa_bits = 32;
+#endif
     }
 
     /*
diff -ru --un qemu-7.2.0/hw/audio/Kconfig qemu-utm-7.2.0/hw/audio/Kconfig
--- qemu-7.2.0/hw/audio/Kconfig	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/audio/Kconfig	2022-12-26 13:45:03
@@ -47,3 +47,6 @@
 
 config CS4231
     bool
+
+config SCREAMER
+    bool
diff -ru --un qemu-7.2.0/hw/audio/meson.build qemu-utm-7.2.0/hw/audio/meson.build
--- qemu-7.2.0/hw/audio/meson.build	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/audio/meson.build	2022-12-26 13:45:03
@@ -12,3 +12,4 @@
 softmmu_ss.add(when: 'CONFIG_SB16', if_true: files('sb16.c'))
 softmmu_ss.add(when: 'CONFIG_VT82C686', if_true: files('via-ac97.c'))
 softmmu_ss.add(when: 'CONFIG_WM8750', if_true: files('wm8750.c'))
+softmmu_ss.add(when: 'CONFIG_SCREAMER', if_true: files('screamer.c'))
diff -ru --un qemu-7.2.0/hw/audio/screamer.c qemu-utm-7.2.0/hw/audio/screamer.c
--- qemu-7.2.0/hw/audio/screamer.c	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/hw/audio/screamer.c	2022-12-26 13:45:03
@@ -0,0 +1,986 @@
+/*
+ * File: Screamer.c
+ * Description: Implement the Screamer sound chip used in Apple Macintoshes.
+ * It works by filling a buffer, then playing the buffer.
+ */
+
+#include "qemu/osdep.h"
+#include "audio/audio.h"
+#include "hw/hw.h"
+#include "hw/irq.h"
+#include <inttypes.h>
+#include "hw/ppc/mac_dbdma.h"
+#include "hw/qdev-properties.h"
+#include "migration/vmstate.h"
+#include "include/hw/audio/screamer.h"
+
+#define DEBUG_SCREAMER 0
+#define DPRINTF(fmt, ...) \
+do { if (DEBUG_SCREAMER) { printf(fmt , ## __VA_ARGS__); } } while (0)
+
+#define SOUND_CONTROL_REG  0
+#define CODEC_CONTROL_REG  1
+#define CODEC_STATUS_REG   2
+#define CLIP_COUNT_REG     3
+#define BYTE_SWAP_REG      4
+#define FRAME_COUNT_REG    5
+
+#define AWACS_BUSY         0x01000000
+
+/* Used with AWACS register 1 */
+#define RECALIBRATE         0x004
+#define LOOPTHRU            0x040
+#define SPEAKER_MUTE        0x080
+#define HEADPHONE_MUTE      0x200
+#define OUTPUT_ZERO         0x400
+#define OUTPUT_ONE          0x800
+#define PARALLEL_OUTPUT     0xc00
+
+/* Function prototypes */
+static uint32_t set_busy_bit(uint32_t value, int bit);
+static uint32_t set_part_ready_bit(uint32_t value, int bit_value);
+static uint32_t set_revision(uint32_t input_value);
+static uint32_t set_manufacturer(uint32_t input_value);
+static int get_sampling_rate(ScreamerState *s);
+static uint32_t get_frame_count_reg(ScreamerState *s);
+static void add_to_speaker_buffer(DBDMA_io *io);
+static void dma_request(DBDMA_io *io);
+
+
+/**************************** Getters *************************/
+
+/* Returns the codec control register's encoded AWACS address */
+static uint8_t get_codec_control_address(uint32_t value)
+{
+    uint8_t return_value;
+    return_value = (value >> 12) & 0x00000fff;
+    return return_value;
+}
+
+
+static uint32_t get_sound_control_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->sound_control);
+    return s->sound_control;
+}
+
+/* The AWACS registers are accessed thru this register */
+static uint32_t get_codec_control_reg(ScreamerState *s)
+{
+    int awacs_register = get_codec_control_address(s->codec_control);
+    uint32_t return_value = s->awacs[awacs_register];
+    return_value = set_busy_bit(return_value, 0); /* Tell CPU we are ready */
+    DPRINTF("%s() called - returned 0x%x\tAWACS register: %d\n", __func__,
+            return_value, awacs_register);
+    return return_value;
+}
+
+/*
+ * Determines if the readback bit is set.
+ * It is used by the Codec Control register.
+ */
+static bool readback_enabled(ScreamerState *s)
+{
+/* Note: bit zero is the readback enabled bit */
+    if (s->awacs[7] & 1) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+static uint32_t get_codec_status_reg(ScreamerState *s)
+{
+    uint32_t return_value;
+
+    /* if in readback mode - return AWACS register value */
+    if (readback_enabled(s)) {
+        int awacs_register = (s->awacs[7] & 0xe) >> 1;
+        s->awacs[7] = s->awacs[7] & 0xfffffffe; /* turn off readback mode */
+        return_value = s->awacs[awacs_register] << 4;
+        DPRINTF("readback enable bit is set, returning AWACS register %d\t"
+                "value:0x%x\n", awacs_register, return_value);
+
+        return return_value;
+    }
+
+    /* Tell CPU we are ready */
+    return_value = set_part_ready_bit(s->codec_status, 1);
+
+    /* Set Revision to Screamer */
+    return_value = set_revision(return_value);
+
+    /* Set the Manufacturer to Crystal */
+    return_value = set_manufacturer(return_value);
+    DPRINTF("%s() called - returned 0x%x\n", __func__, return_value);
+
+    return return_value;
+}
+
+static uint32_t get_clip_count_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->clip_count);
+    uint32_t return_value;
+    return_value = s->clip_count;
+    /* This is reset everytime it is read */
+    s->clip_count = 0;
+    return return_value;
+}
+
+static uint32_t get_byte_swap_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->byte_swap);
+    /*
+     * If all you hear is noise, it could be this register reporting the
+     * wrong value.
+     */
+    return s->byte_swap ? 0 : 1;
+}
+
+/*
+ * Returns the frame (sample) count
+ */
+static uint32_t get_frame_count_reg(ScreamerState *s)
+{
+    DPRINTF("%s() called - returned 0x%x\n", __func__, s->frame_count);
+    return s->frame_count;
+}
+
+static uint8_t get_left_vol(uint32_t value)
+{
+    return value & 0xf;
+}
+
+static uint8_t get_right_vol(uint32_t value)
+{
+    return value & 0x3c0 >> 6;
+}
+
+/*
+ * Returns the sampling rate.
+ * If the audio is playing back too fast or too slow, this function may be the
+ * cause.
+ */
+static int get_sampling_rate(ScreamerState *s)
+{
+    uint32_t screamer_rate = s->sound_control & 0x700;
+    int return_value;
+
+    /* All return values are in Hertz */
+    switch (screamer_rate) {
+    case 0x0:
+        return_value = 44100;
+        break;
+    case 0x100:
+        return_value = 29400;
+        break;
+    case 0x200:
+        return_value = 22050;
+        break;
+    case 0x300:
+        return_value = 17640;
+        break;
+    case 0x400:
+        return_value = 14700;
+        break;
+    case 0x500:
+        return_value = 11025;
+        break;
+    case 0x600:
+        return_value = 8820;
+        break;
+    case 0x700:
+        return_value = 7350;
+        break;
+    default:
+        DPRINTF("get_sampling_rate() unknown value: 0x%x\nDefaulting to"
+                " 44100 Hz.\n", screamer_rate);
+        return 44100;
+}
+    DPRINTF("%s() called - returning %dHz\n", __func__, return_value);
+    return return_value;
+}
+
+/**************************** End of getters *************************/
+
+/***************************** Speaker call back *************************/
+
+/* resets the play and buffer position markers */
+static void reset_markers(ScreamerState *s)
+{
+    s->spk_play_position = 0;
+    s->spk_buffer_position = 0;
+}
+
+
+/* Sends the samples to the host for playing */
+static void send_samples_to_host(ScreamerState *s, int max_samples)
+{
+    int write_length, requested_length;
+    requested_length = MIN(max_samples, (s->spk_buffer_position -
+                                         s->spk_play_position));
+    write_length = AUD_write(s->speaker_voice,
+                             &s->spk_buffer[s->spk_play_position],
+                             requested_length);
+    DPRINTF("requested length: %d\twrite length: %d\t",
+            requested_length, write_length);
+    s->spk_play_position += write_length;
+    DPRINTF("AUD_write %d/%d\n", s->spk_play_position, s->spk_buffer_position);
+    s->frame_count += write_length;
+}
+
+
+/*
+ * Called by QEMU's audio system to tell the output backend to send samples
+ * from the buffer to the host sound system.
+ * opaque: a pointer to the ScreamerState instance.
+ * max_samples: the number of samples that can be sent to the hardware buffer.
+ */
+static void speaker_callback(void *opaque, int max_samples)
+{
+    ScreamerState *s = (ScreamerState *) opaque;
+
+    /* if we have more samples to play */
+    if (s->spk_buffer_position > 0) {
+        if (s->spk_buffer_position > s->spk_play_position) {
+            DPRINTF("%s() called - max_samples: %d\n", __func__, max_samples);
+            send_samples_to_host(s, max_samples);
+        }
+        if (s->spk_play_position >= s->spk_buffer_position) {
+            DPRINTF("done playing buffer\n");
+            DPRINTF("pp: %d\tbp: %d\n", s->spk_play_position,
+                    s->spk_buffer_position);
+            if (s->spk_play_position > s->spk_buffer_position) {
+                DPRINTF("Error detected! - pp > bp\n\a");
+            }
+            reset_markers(s);
+            /* play postponed samples */
+            if (s->dma_io.len > 0) {
+                DPRINTF("playing postponed samples\n");
+                add_to_speaker_buffer(&s->dma_io);
+                return;
+            }
+        }
+    }
+}
+
+/************************* End of speaker call back *************************/
+
+
+/* Opens the speaker's voice */
+static void open_speaker_voice(ScreamerState *s)
+{
+    DPRINTF("%s() called\n", __func__);
+
+    /* if voice is already open return from function */
+    if (s->speaker_voice != NULL) {
+        DPRINTF("closing speaker voice\n");
+        AUD_close_out(&s->card, s->speaker_voice);
+        s->speaker_voice = NULL;
+    }
+    struct audsettings audio_settings;
+    audio_settings.freq = get_sampling_rate(s);  /* in hertz */
+    audio_settings.nchannels = 2;                /* stereo output */
+    audio_settings.fmt = AUDIO_FORMAT_S16;       /* signed 16 bit */
+    audio_settings.endianness = get_byte_swap_reg(s); /* endianness */
+    s->speaker_voice = AUD_open_out(&s->card, s->speaker_voice, SOUND_CHIP_NAME
+                                    " speaker", s, speaker_callback,
+                                    &audio_settings);
+    if (!s->speaker_voice) {
+        AUD_log(SOUND_CHIP_NAME, "Out voice could not be opened\n");
+    } else {
+        AUD_set_active_out(s->speaker_voice, true);
+    }
+}
+
+
+/******************************* Setters *************************************/
+
+
+/* Updates QEMU's audio backend settings */
+static void set_QEMU_audio_settings(ScreamerState *s)
+{
+    DPRINTF("%s() called\n", __func__);
+    open_speaker_voice(s);
+}
+
+
+/* Return value: 1 = muted  0 = not muted */
+static int is_muted(ScreamerState *s)
+{
+    int mute_state = s->awacs[1] & SPEAKER_MUTE ? 1 : 0;
+    if (s->awacs[1] & SPEAKER_MUTE) {
+        DPRINTF("speaker is muted\n");
+    } else {
+        DPRINTF("speaker is unmuted\n");
+    }
+
+    if (s->awacs[1] & HEADPHONE_MUTE) {
+        DPRINTF("headphone is muted\n");
+    } else {
+        DPRINTF("headphone is unmuted\n");
+    }
+    return mute_state;
+}
+
+
+/* Converts Screamer's volume system to QEMU's system */
+static int screamer_to_qemu_volume(int x)
+{
+    return -16 * x + 240;
+}
+
+
+/* Sets QEMU's volume. */
+static void set_volume(ScreamerState *s)
+{
+    int should_mute = is_muted(s);
+
+    /* Get Screamer volume values */
+    uint8_t left_vol = get_left_vol(s->awacs[4]);
+    uint8_t right_vol = get_right_vol(s->awacs[4]);
+    DPRINTF("set_volume() called - M:%d\tL:%d\tR:%d\n", should_mute, left_vol,
+            right_vol);
+
+    /* Convert Screamer to QEMU volume values */
+    left_vol = screamer_to_qemu_volume(left_vol);
+    right_vol = screamer_to_qemu_volume(right_vol);
+    DPRINTF("QEMU volume: L:%d\tR:%d\n", left_vol, right_vol);
+    AUD_set_volume_out(s->speaker_voice, should_mute, left_vol, right_vol);
+}
+
+
+/* Sets the sound control register */
+static void set_sound_control_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_sound_control_reg() called - value: 0x%x\n", value);
+    s->sound_control = value;
+    set_QEMU_audio_settings(s);
+}
+
+
+/* Used for input gain only - can be ignored for now. */
+static void set_awacs_0_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 0 to 0x%x\n", s->awacs[0]);
+    s->awacs[0] = new_value;
+}
+
+
+static void set_awacs_1_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 1 to 0x%x\n", new_value);
+
+    s->awacs[1] = new_value;
+
+    /* If recalibration requested */
+    if (new_value & RECALIBRATE) {
+        DPRINTF("Recalibration requested - unimplemented\n");
+        new_value = new_value ^ RECALIBRATE; /* Turn off recalibrate bit */
+    }
+
+    /* If loop thru set - what does this mean? */
+    if (new_value & LOOPTHRU) {
+        DPRINTF("Loopthru enabled - doing nothing\n");
+    }
+
+    /* Set headphone jack mute state */
+    if (new_value & HEADPHONE_MUTE) {
+        DPRINTF("Headphone muted\n");
+    }
+
+    else {
+        DPRINTF("Headphone unmuted\n");
+    }
+
+    if (new_value & SPEAKER_MUTE) {
+        DPRINTF("Speaker muted\n");
+    }
+
+    else {
+        DPRINTF("Speaker unmuted\n");
+    }
+
+    if (new_value & OUTPUT_ZERO) {
+        DPRINTF("output zero set - not sure what this means\n");
+    }
+
+    if (new_value & OUTPUT_ONE) {
+        DPRINTF("output one set - not sure what this means\n");
+    }
+
+    if (new_value & PARALLEL_OUTPUT) {
+        DPRINTF("parallel port enabled - but no parallel port here\n");
+    }
+
+    set_volume(s);
+}
+
+
+/* This is used for headphone volume - not needed */
+static void set_awacs_2_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 2 to 0x%x\n"
+            "Ignoring change in headphone volume.\n", s->awacs[2]);
+    s->awacs[2] = new_value;
+}
+
+
+/* Unknown register purpose */
+static void set_awacs_3_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 3 to 0x%x\n"
+            "This register has an unknown purpose and does not do anything\n",
+            s->awacs[3]);
+    s->awacs[3] = new_value;
+}
+
+
+/* Mostly deals with speaker volume */
+static void set_awacs_4_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("AWACS register 4 write: 0x%x\n", new_value);
+    s->awacs[4] = new_value;
+    set_volume(s);
+}
+
+
+/* This register is about loop thru stuff I don't understand */
+static void set_awacs_5_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 5 to 0x%x\n"
+            "Loop thru update ignored.\n", s->awacs[5]);
+    s->awacs[5] = new_value;
+}
+
+
+/* Prints the states of the AWACS power register */
+static void print_power_reg_values(uint32_t value)
+{
+    if ((value & 0x3) == 0) {
+        printf("Screamer run state set\n");
+    }
+    if ((value & 0x3) == 1) {
+        printf("Screamer doze state set\n");
+    }
+    if ((value & 0x3) == 2) {
+        printf("Screamer idle state set\n");
+    }
+}
+
+
+/* Power Magement register */
+static void set_awacs_6_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 6 to 0x%x\n"
+            "Power management update ignored.\n", s->awacs[6]);
+    if (DEBUG_SCREAMER) {
+        print_power_reg_values(new_value);
+    }
+    s->awacs[6] = new_value;
+}
+
+
+/* Read Back - repeating something that was sent to this chip? */
+static void set_awacs_7_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("Settings AWACS register 7 to 0x%x\n", new_value);
+    s->awacs[7] = new_value;
+}
+
+
+/* Sets the AWACs registers - a.k.a. shadow registers */
+static void set_awacs_register(ScreamerState *s, uint32_t value)
+{
+    int the_register = get_codec_control_address(value);
+
+    switch (the_register) {
+    case 0:
+        set_awacs_0_reg(s, value);
+        break;
+    case 1:
+        set_awacs_1_reg(s, value);
+        break;
+    case 2:
+        set_awacs_2_reg(s, value);
+        break;
+    case 3:
+        set_awacs_3_reg(s, value);
+        break;
+    case 4:
+        set_awacs_4_reg(s, value);
+        break;
+    case 5:
+        set_awacs_5_reg(s, value);
+        break;
+    case 6:
+        set_awacs_6_reg(s, value);
+        break;
+    case 7:
+        set_awacs_7_reg(s, value);
+        break;
+    default:
+        DPRINTF("Unhandled awacs registers %d\n", the_register);
+    }
+}
+
+
+/* Used to set the AWACS registers */
+static void set_codec_control_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_codec_control_reg() called - value: 0x%x\n", value);
+    s->codec_control = value;
+    set_awacs_register(s, value);
+}
+
+static void set_codec_status_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_codec_status_reg() called - value: 0x%x\n", value);
+    s->codec_status = value;
+}
+
+static void set_clip_count_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("set_clip_count_reg() called - value: 0x%x\n", new_value);
+    s->clip_count = new_value;
+}
+
+static void set_byte_swap_reg(ScreamerState *s, uint32_t value)
+{
+    DPRINTF("set_byte_swap_reg() called - value: 0x%x\n", value);
+    s->byte_swap = value;
+}
+
+static void set_frame_count_reg(ScreamerState *s, uint32_t new_value)
+{
+    DPRINTF("%s() called - value: 0x%x\n", __func__, new_value);
+    s->frame_count = new_value;
+}
+
+/*
+ * Sets the busy bit of codec control register.
+ * It is used to tell the CPU to wait.
+ * value: the codec control register's value
+ * bit_value: used to set or disable the busy bit
+ */
+static uint32_t set_busy_bit(uint32_t value, int bit_value)
+{
+    const int busy_bit = 0x01000000;
+    uint32_t return_value;
+    if (bit_value == 1)  /* Set this bit */
+        return_value = (value | busy_bit);
+    else /* bit_value == 0  Disable this bit */
+        return_value = (value & ~busy_bit);
+    return return_value;
+}
+
+
+/*
+ * Sets the part ready bit of the codec status register
+ * value: the codec status register's value
+ * bit_value: used to set or disable the part ready bit
+ */
+static uint32_t set_part_ready_bit(uint32_t value, int bit_value)
+{
+    const int part_ready_bit = 0x00400000;
+    uint32_t return_value;
+    if (bit_value == 1)  /* Set this bit */
+        return_value = (value | part_ready_bit);
+    else /* bit_value == 0  Disable this bit */
+        return_value = (value & ~part_ready_bit);
+    return return_value;
+}
+
+/* Sets bits 12 and 13 to 1 to indicate the Screamer revision */
+static uint32_t set_revision(uint32_t input_value)
+{
+    uint32_t return_value;
+    return_value = input_value | 0x3000;
+    return return_value;
+}
+
+/* Sets bit 8 to indicate Crystal as the manufacturer */
+static uint32_t set_manufacturer(uint32_t input_value)
+{
+    uint32_t return_value;
+    return_value = input_value | 0x100;
+    return return_value;
+}
+
+
+/************************** End of Setters *********************************/
+
+
+/*************************** DMA functions *********************************/
+
+/*
+ * Sends audio samples from a microphone or line-in to memory.
+ * Used for sound input.
+ * Currently only prevents a deadlock condition with Mac OS 9.
+ */
+static void screamer_to_dma(DBDMA_io *io)
+{
+    DPRINTF("%s() called\n", __func__);
+    ScreamerState *s = (ScreamerState *)io->opaque;
+    DBDMAState *dbs = s->dbdma;
+    DBDMA_channel *ch = &dbs->channels[0x12];
+    ch->regs[DBDMA_STATUS] |= DEAD;
+    ch->regs[DBDMA_STATUS] &= ~ACTIVE;
+    io->dma_end(io);
+    return;
+}
+
+
+static void print_dma_info(DBDMA_io *io)
+{
+    #define RUN        0x8000
+    #define PAUSE      0x4000
+    #define FLUSH      0x2000
+    #define WAKE       0x1000
+    #define DEAD       0x0800
+    #define ACTIVE     0x0400
+    #define BT         0x0100
+    #define DEVSTAT    0x00ff
+
+    /*
+     * RUN and PAUSE are bits under software control only.
+     * FLUSH and WAKE are set by SW and cleared by hardware.
+     * DEAD, ACTIVE and BT are only under hardware control.
+     */
+
+    DBDMA_channel *ch = io->channel;
+    printf("DMA FLAGS: ");
+
+    if (ch->regs[DBDMA_STATUS] & RUN) {
+        printf("RUN ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & ACTIVE) {
+        printf("ACTIVE ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & PAUSE) {
+        printf("PAUSE ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & DEAD) {
+        printf("DEAD ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & WAKE) {
+        printf("WAKE ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & BT) {
+        printf("BT ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & DEVSTAT) {
+        printf("DEVSTAT ");
+    }
+
+    if (ch->regs[DBDMA_STATUS] & FLUSH) {
+        printf("FLUSH ");
+    }
+
+    if (ch->io.processing == true) {
+        printf("processing  ");
+    }
+
+    printf("\n");
+}
+
+/* Tell the DMA controller we request more samples */
+static void dma_request(DBDMA_io *io)
+{
+    DPRINTF("%s() called\n", __func__);
+    if (DEBUG_SCREAMER) {
+        print_dma_info(io);
+    }
+    io->len = 0;
+    io->dma_end(io);
+}
+
+
+/* Adds sample data to the buffer */
+static void add_to_speaker_buffer(DBDMA_io *io)
+{
+    ScreamerState *s = (ScreamerState *) io->opaque;
+
+    if (s->spk_buffer_position + io->len > MAX_BUFFER_SIZE) {
+        /* postpone calling these samples until the buffer has been emptied */
+        memcpy(&s->dma_io, io, sizeof(DBDMA_io));
+        return;
+    }
+    dma_memory_read(&address_space_memory, io->addr,
+                    &s->spk_buffer[s->spk_buffer_position], io->len,
+                    MEMTXATTRS_UNSPECIFIED);
+    s->spk_buffer_position += io->len;
+    DPRINTF("%s() called - len: %d pos: %d/%d\n", __func__, io->len,
+            s->spk_buffer_position, MAX_BUFFER_SIZE);
+
+    dma_request(io);
+}
+
+/*
+ * Called by the DMA chip to transfer samples from memory to the
+ * Screamer chip.
+ * Used for sound output.
+ */
+static void dma_to_screamer(DBDMA_io *io)
+{
+    add_to_speaker_buffer(io);
+}
+
+
+/*
+ * This will flush the audio buffer of previous audio - eliminating previous
+ * audio playback.
+ */
+static void send_silence_to_speaker(ScreamerState *s)
+{
+    DPRINTF("Silencing audio buffer...\n");
+    int length = MAX_BUFFER_SIZE;
+    s->spk_buffer_position = length;
+    s->spk_play_position = 0;
+    memset(s->spk_buffer, 0, length);
+    s->dma_io.len = 0; /* stop any postponed samples from playing */
+}
+
+
+/* This is called after audio stops playing */
+static void dma_send_flush(DBDMA_io *io)
+{
+    DPRINTF("dma_send_flush() called\n");
+    if (DEBUG_SCREAMER) {
+        print_dma_info(io);
+    }
+    ScreamerState *s = (ScreamerState *)io->opaque;
+    reset_markers(s);
+    send_silence_to_speaker(s);
+    if (io->len > 0) {
+        dma_request(io);
+    }
+}
+
+
+static void dma_receive_flush(DBDMA_io *io)
+{
+    DPRINTF("dma_receive_flush() called\n");
+}
+
+
+/* Set the functions the DMA system will call */
+void screamer_register_dma_functions(ScreamerState *s, void *dbdma,
+                                   int send_channel, int receive_channel)
+{
+    DPRINTF("%s() called\n", __func__);
+    DPRINTF("send channel: %d\treceive channel: %d\n", send_channel,
+           receive_channel);
+    s->dbdma = dbdma;
+
+    /* Setup the DMA send system */
+    DBDMA_register_channel(s->dbdma, send_channel, s->dma_send_irq,
+                           dma_to_screamer, dma_send_flush, s);
+
+    /* Setup the DMA receive system */
+    DBDMA_register_channel(s->dbdma, receive_channel, s->dma_receive_irq,
+                           screamer_to_dma, dma_receive_flush, s);
+}
+
+/************************* End of DMA functions **************************/
+
+/* Resets this sound chip */
+static void screamer_reset(DeviceState *d)
+{
+    DPRINTF("screamer_reset() called\n");
+    ScreamerState *s = SCREAMER(d);
+    set_sound_control_reg(s, 0);
+    set_codec_control_reg(s, 0);
+    set_codec_status_reg(s, 0);
+    set_clip_count_reg(s, 0);
+    set_byte_swap_reg(s, 0);
+    set_frame_count_reg(s, 0);
+    int i, num_awacs_regs = 8;
+    for (i = 0; i < num_awacs_regs; i++) {
+        s->awacs[i] = 0;
+    }
+    set_QEMU_audio_settings(s);
+    reset_markers(s);
+    s->dma_io.len = 0;
+}
+
+/* Called when the CPU reads the memory addresses assigned to Screamer */
+static uint64_t screamer_mmio_read(void *opaque, hwaddr addr, unsigned size)
+{
+    ScreamerState *state = opaque;
+    uint32_t return_value;
+
+    addr = addr >> 4;
+    switch (addr) {
+    case SOUND_CONTROL_REG:
+        return_value = get_sound_control_reg(state);
+        break;
+    case CODEC_CONTROL_REG:
+        return_value = get_codec_control_reg(state);
+        break;
+    case CODEC_STATUS_REG:
+        return_value = get_codec_status_reg(state);
+        break;
+    case CLIP_COUNT_REG:
+        return_value = get_clip_count_reg(state);
+        break;
+    case BYTE_SWAP_REG:
+        return_value = get_byte_swap_reg(state);
+        break;
+    case FRAME_COUNT_REG:
+        return_value = get_frame_count_reg(state);
+        break;
+    default:
+        DPRINTF("Unknown register read - addr:%" HWADDR_PRIx "\tsize:%d\n",
+                addr, size);
+        return_value = 12021981; /* Value used for debugging purposes */
+    }
+    DPRINTF("screamer_mmio_read() called addr: %" HWADDR_PRIx "  size: %d",
+            addr >> 4, size);
+    DPRINTF("  returning 0x%x\n", return_value);
+    return return_value;
+}
+
+
+/* Called when the CPU writes to the memory addresses assigned to Screamer */
+static void screamer_mmio_write(void *opaque, hwaddr addr, uint64_t raw_value,
+                                unsigned size)
+{
+    DPRINTF("screamer_mmio_write() called - size: %d\n", size);
+    ScreamerState *state = opaque;
+    uint32_t value = raw_value & 0xffffffff;
+    addr = addr >> 4;
+
+    switch (addr) {
+    case SOUND_CONTROL_REG:
+        set_sound_control_reg(state, value);
+        break;
+    case CODEC_CONTROL_REG:
+        set_codec_control_reg(state, value);
+        break;
+    case CODEC_STATUS_REG:
+        set_codec_status_reg(state, value);
+        break;
+    case CLIP_COUNT_REG:
+        set_clip_count_reg(state, value);
+        break;
+    case BYTE_SWAP_REG:
+        set_byte_swap_reg(state, value);
+        break;
+    case FRAME_COUNT_REG:
+        set_frame_count_reg(state, value);
+        break;
+    default:
+        DPRINTF("Unknown register write - addr:%" HWADDR_PRIx "\tvalue:%d\n",
+                addr, value);
+    }
+}
+
+/* Used for memory_region_init_io() for memory mapped I/O */
+static const MemoryRegionOps screamer_ops = {
+    .read = screamer_mmio_read,
+    .write = screamer_mmio_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+    .valid = {
+        .min_access_size = 4,
+        .max_access_size = 4
+    }
+};
+
+/* Called when the device has become active */
+static void screamer_realize(DeviceState *dev, Error **errp)
+{
+    DPRINTF("screamer_realize() called\n");
+    screamer_reset(dev);
+}
+
+
+/*
+ * Called when an instance of the Screamer device is created.
+ * Also called when this HMP command is called: device_add screamer
+ */
+static void screamer_init(Object *obj)
+{
+    DPRINTF("screamer_init() called\n");
+
+    ScreamerState *s = (ScreamerState *)obj;
+    SysBusDevice *d = SYS_BUS_DEVICE(obj);
+    const int region_size = 5 * 32;
+
+    /* Makes the read and write ops work */
+    memory_region_init_io(&s->io_memory_region, OBJECT(s),
+                          &screamer_ops, s, SOUND_CHIP_NAME, region_size);
+
+    /* Sets the SysBusDevice's memory property */
+    sysbus_init_mmio(d, &s->io_memory_region);
+
+    /* Setup all the interrupt requests */
+    sysbus_init_irq(d, &s->irq);
+    sysbus_init_irq(d, &s->dma_send_irq);
+    sysbus_init_irq(d, &s->dma_receive_irq);
+
+    /* Registers Screamer with QEMU's audio system */
+    AUD_register_card(SOUND_CHIP_NAME, &s->card);
+}
+
+
+/*
+ * When saving and restoring the state of the VM, this is used to save and
+ * restore the registers.
+ */
+static const VMStateDescription vmstate_screamer = {
+    .name = "Screamer",
+    .version_id = 1,
+    .minimum_version_id = 1,
+    .fields = (VMStateField[]) {
+        VMSTATE_UINT16_ARRAY(awacs, ScreamerState, 8), /* 8 AWACS registers */
+        VMSTATE_UINT32(sound_control, ScreamerState),
+        VMSTATE_UINT32(codec_control, ScreamerState),
+        VMSTATE_UINT32(codec_status, ScreamerState),
+        VMSTATE_UINT32(clip_count, ScreamerState),
+        VMSTATE_UINT32(byte_swap, ScreamerState),
+        VMSTATE_UINT32(frame_count, ScreamerState),
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+
+/*
+ * Sets the class data. It is like polymorphism and inheritance in object
+ * oriented languages.
+ */
+static void screamer_class_init(ObjectClass *class, void *data)
+{
+    DPRINTF("screamer_class_init() called\n");
+    DeviceClass *dc = DEVICE_CLASS(class);
+    dc->realize = screamer_realize;
+    dc->reset = screamer_reset;
+    dc->desc = "Apple Screamer";
+    dc->vmsd = &vmstate_screamer;
+    dc->hotpluggable = false;
+}
+
+/* Used for QOM function registration */
+static const TypeInfo screamer_info = {
+    .name          = "screamer",
+    .parent        = TYPE_SYS_BUS_DEVICE,
+    .instance_size = sizeof(ScreamerState),
+    .instance_init = screamer_init,
+    .class_init    = screamer_class_init,
+};
+
+/* QOM registration of above functions for calling */
+static void screamer_register_types(void)
+{
+    DPRINTF("screamer_register_types() called\n");
+    type_register_static(&screamer_info);
+}
+
+/* QEMU Object Model (QOM) stuff */
+type_init(screamer_register_types)
diff -ru --un qemu-7.2.0/hw/display/meson.build qemu-utm-7.2.0/hw/display/meson.build
--- qemu-7.2.0/hw/display/meson.build	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/display/meson.build	2022-12-26 13:45:03
@@ -79,6 +79,16 @@
   hw_display_modules += {'virtio-gpu-gl': virtio_gpu_gl_ss}
 endif
 
+if config_all_devices.has_key('CONFIG_FW_CFG_DMA')
+  virtio_ramfb_ss = ss.source_set()
+  virtio_ramfb_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('virtio-ramfb.c'))
+  hw_display_modules += {'virtio-ramfb': virtio_ramfb_ss}
+  virtio_ramfb_gl_ss = ss.source_set()
+  virtio_ramfb_gl_ss.add(when: ['CONFIG_FW_CFG_DMA', virgl, opengl],
+                       if_true: files('virtio-ramfb-gl.c'))
+  hw_display_modules += {'virtio-ramfb-gl': virtio_ramfb_gl_ss}
+endif
+
 if config_all_devices.has_key('CONFIG_VIRTIO_PCI')
   virtio_gpu_pci_ss = ss.source_set()
   virtio_gpu_pci_ss.add(when: ['CONFIG_VIRTIO_GPU', 'CONFIG_VIRTIO_PCI'],
diff -ru --un qemu-7.2.0/hw/display/virtio-gpu-virgl.c qemu-utm-7.2.0/hw/display/virtio-gpu-virgl.c
--- qemu-7.2.0/hw/display/virtio-gpu-virgl.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/display/virtio-gpu-virgl.c	2022-12-26 13:45:03
@@ -140,12 +140,39 @@
     }
 }
 
+static GLuint virgl_borrow_texture_for_scanout(uint32_t id, bool *y_0_top,
+                                               uint32_t *width,
+                                               uint32_t *height)
+{
+    struct virgl_renderer_texture_info info;
+    int ret;
+
+    memset(&info, 0, sizeof(info));
+
+    ret = virgl_renderer_borrow_texture_for_scanout(id, &info);
+    if (ret == -1) {
+        return 0;
+    }
+
+    if (y_0_top) {
+        *y_0_top = info.flags & VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP;
+    }
+
+    if (width) {
+        *width = info.width;
+    }
+
+    if (height) {
+        *height = info.height;
+    }
+
+    return info.tex_id;
+}
+
 static void virgl_cmd_set_scanout(VirtIOGPU *g,
                                   struct virtio_gpu_ctrl_command *cmd)
 {
     struct virtio_gpu_set_scanout ss;
-    struct virgl_renderer_resource_info info;
-    int ret;
 
     VIRTIO_GPU_FILL_CMD(ss);
     trace_virtio_gpu_cmd_set_scanout(ss.scanout_id, ss.resource_id,
@@ -159,24 +186,13 @@
     }
     g->parent_obj.enable = 1;
 
-    memset(&info, 0, sizeof(info));
-
     if (ss.resource_id && ss.r.width && ss.r.height) {
-        ret = virgl_renderer_resource_get_info(ss.resource_id, &info);
-        if (ret == -1) {
-            qemu_log_mask(LOG_GUEST_ERROR,
-                          "%s: illegal resource specified %d\n",
-                          __func__, ss.resource_id);
-            cmd->error = VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID;
-            return;
-        }
         qemu_console_resize(g->parent_obj.scanout[ss.scanout_id].con,
                             ss.r.width, ss.r.height);
         virgl_renderer_force_ctx_0();
         dpy_gl_scanout_texture(
-            g->parent_obj.scanout[ss.scanout_id].con, info.tex_id,
-            info.flags & VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP,
-            info.width, info.height,
+            g->parent_obj.scanout[ss.scanout_id].con, ss.resource_id,
+            virgl_borrow_texture_for_scanout,
             ss.r.x, ss.r.y, ss.r.width, ss.r.height);
     } else {
         dpy_gfx_replace_surface(
diff -ru --un qemu-7.2.0/hw/display/virtio-ramfb-gl.c qemu-utm-7.2.0/hw/display/virtio-ramfb-gl.c
--- qemu-7.2.0/hw/display/virtio-ramfb-gl.c	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/hw/display/virtio-ramfb-gl.c	2022-12-26 13:45:03
@@ -0,0 +1,50 @@
+#include "qemu/osdep.h"
+#include "hw/pci/pci.h"
+#include "hw/qdev-properties.h"
+#include "hw/virtio/virtio-gpu.h"
+#include "hw/display/vga.h"
+#include "qapi/error.h"
+#include "qemu/module.h"
+#include "virtio-ramfb.h"
+#include "qom/object.h"
+
+#define TYPE_VIRTIO_RAMFB_GL "virtio-ramfb-gl"
+
+typedef struct VirtIORAMFBGL VirtIORAMFBGL;
+DECLARE_INSTANCE_CHECKER(VirtIORAMFBGL, VIRTIO_RAMFB_GL,
+                         TYPE_VIRTIO_RAMFB_GL)
+
+struct VirtIORAMFBGL {
+    VirtIORAMFBBase parent_obj;
+
+    VirtIOGPUGL   vdev;
+};
+
+static void virtio_ramfb_gl_inst_initfn(Object *obj)
+{
+    VirtIORAMFBGL *dev = VIRTIO_RAMFB_GL(obj);
+    
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU_GL);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+}
+
+
+static VirtioPCIDeviceTypeInfo virtio_ramfb_gl_info = {
+    .generic_name  = TYPE_VIRTIO_RAMFB_GL,
+    .parent        = TYPE_VIRTIO_RAMFB_BASE,
+    .instance_size = sizeof(VirtIORAMFBGL),
+    .instance_init = virtio_ramfb_gl_inst_initfn,
+};
+module_obj(TYPE_VIRTIO_RAMFB_GL);
+
+static void virtio_ramfb_register_types(void)
+{
+    if (have_vga) {
+        virtio_pci_types_register(&virtio_ramfb_gl_info);
+    }
+}
+
+type_init(virtio_ramfb_register_types)
+
+module_dep("hw-display-virtio-ramfb");
diff -ru --un qemu-7.2.0/hw/display/virtio-ramfb.c qemu-utm-7.2.0/hw/display/virtio-ramfb.c
--- qemu-7.2.0/hw/display/virtio-ramfb.c	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/hw/display/virtio-ramfb.c	2022-12-26 13:45:03
@@ -0,0 +1,191 @@
+#include "qemu/osdep.h"
+#include "sysemu/sysemu.h"
+#include "hw/pci/pci.h"
+#include "ui/console.h"
+#include "hw/qdev-properties.h"
+#include "virtio-ramfb.h"
+#include "qapi/error.h"
+#include "qom/object.h"
+
+static int virtio_ramfb_get_flags(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->get_flags) {
+        return g->hw_ops->get_flags(g);
+    } else {
+        return 0;
+    }
+}
+
+static void virtio_ramfb_invalidate_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->invalidate(g);
+    }
+}
+
+static void virtio_ramfb_text_update(void *opaque, console_ch_t *chardata)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->text_update) {
+        g->hw_ops->text_update(g, chardata);
+    }
+}
+
+static void virtio_ramfb_update_display(void *opaque)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->enable) {
+        g->hw_ops->gfx_update(g);
+    } else {
+        ramfb_display_update(g->scanout[0].con, vramfb->ramfb);
+    }
+}
+
+static void virtio_ramfb_ui_info(void *opaque, uint32_t idx, QemuUIInfo *info)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->ui_info) {
+        g->hw_ops->ui_info(g, idx, info);
+    }
+}
+
+static void virtio_ramfb_gl_block(void *opaque, bool block)
+{
+    VirtIORAMFBBase *vramfb = opaque;
+    VirtIOGPUBase *g = vramfb->vgpu;
+
+    if (g->hw_ops->gl_block) {
+        g->hw_ops->gl_block(g, block);
+    }
+}
+
+static const GraphicHwOps virtio_ramfb_ops = {
+    .get_flags = virtio_ramfb_get_flags,
+    .invalidate = virtio_ramfb_invalidate_display,
+    .gfx_update = virtio_ramfb_update_display,
+    .text_update = virtio_ramfb_text_update,
+    .ui_info = virtio_ramfb_ui_info,
+    .gl_block = virtio_ramfb_gl_block,
+};
+
+static const VMStateDescription vmstate_virtio_ramfb = {
+    .name = "virtio-ramfb",
+    .version_id = 2,
+    .minimum_version_id = 2,
+    .fields = (VMStateField[]) {
+        /* no pci stuff here, saving the virtio device will handle that */
+        /* FIXME */
+        VMSTATE_END_OF_LIST()
+    }
+};
+
+/* RAMFB device wrapper around PCI device around virtio GPU */
+static void virtio_ramfb_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
+{
+    VirtIORAMFBBase *vramfb = VIRTIO_RAMFB_BASE(vpci_dev);
+    VirtIOGPUBase *g = vramfb->vgpu;
+    int i;
+
+    /* init virtio bits */
+    virtio_pci_force_virtio_1(vpci_dev);
+    if (!qdev_realize(DEVICE(g), BUS(&vpci_dev->bus), errp)) {
+        return;
+    }
+
+    /* init ramfb */
+    vramfb->ramfb = ramfb_setup(errp);
+    graphic_console_set_hwops(g->scanout[0].con, &virtio_ramfb_ops, vramfb);
+
+    for (i = 0; i < g->conf.max_outputs; i++) {
+        object_property_set_link(OBJECT(g->scanout[i].con), "device",
+                                 OBJECT(vpci_dev), &error_abort);
+    }
+}
+
+static void virtio_ramfb_reset(DeviceState *dev)
+{
+    VirtIORAMFBBaseClass *klass = VIRTIO_RAMFB_BASE_GET_CLASS(dev);
+
+    /* reset virtio-gpu */
+    klass->parent_reset(dev);
+}
+
+static Property virtio_ramfb_base_properties[] = {
+    DEFINE_VIRTIO_GPU_PCI_PROPERTIES(VirtIOPCIProxy),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static void virtio_ramfb_base_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    VirtioPCIClass *k = VIRTIO_PCI_CLASS(klass);
+    VirtIORAMFBBaseClass *v = VIRTIO_RAMFB_BASE_CLASS(klass);
+    PCIDeviceClass *pcidev_k = PCI_DEVICE_CLASS(klass);
+
+    set_bit(DEVICE_CATEGORY_DISPLAY, dc->categories);
+    device_class_set_props(dc, virtio_ramfb_base_properties);
+    dc->vmsd = &vmstate_virtio_ramfb;
+    dc->hotpluggable = false;
+    device_class_set_parent_reset(dc, virtio_ramfb_reset,
+                                  &v->parent_reset);
+
+    k->realize = virtio_ramfb_realize;
+    pcidev_k->class_id = PCI_CLASS_DISPLAY_OTHER;
+}
+
+static const TypeInfo virtio_ramfb_base_info = {
+    .name          = TYPE_VIRTIO_RAMFB_BASE,
+    .parent        = TYPE_VIRTIO_PCI,
+    .instance_size = sizeof(VirtIORAMFBBase),
+    .class_size    = sizeof(VirtIORAMFBBaseClass),
+    .class_init    = virtio_ramfb_base_class_init,
+    .abstract      = true,
+};
+
+#define TYPE_VIRTIO_RAMFB "virtio-ramfb"
+
+typedef struct VirtIORAMFB VirtIORAMFB;
+DECLARE_INSTANCE_CHECKER(VirtIORAMFB, VIRTIO_RAMFB,
+                         TYPE_VIRTIO_RAMFB)
+
+struct VirtIORAMFB {
+    VirtIORAMFBBase parent_obj;
+
+    VirtIOGPU     vdev;
+};
+
+static void virtio_ramfb_inst_initfn(Object *obj)
+{
+    VirtIORAMFB *dev = VIRTIO_RAMFB(obj);
+
+    virtio_instance_init_common(obj, &dev->vdev, sizeof(dev->vdev),
+                                TYPE_VIRTIO_GPU);
+    VIRTIO_RAMFB_BASE(dev)->vgpu = VIRTIO_GPU_BASE(&dev->vdev);
+}
+
+static VirtioPCIDeviceTypeInfo virtio_ramfb_info = {
+    .generic_name  = TYPE_VIRTIO_RAMFB,
+    .parent        = TYPE_VIRTIO_RAMFB_BASE,
+    .instance_size = sizeof(VirtIORAMFB),
+    .instance_init = virtio_ramfb_inst_initfn,
+};
+
+static void virtio_ramfb_register_types(void)
+{
+    type_register_static(&virtio_ramfb_base_info);
+    virtio_pci_types_register(&virtio_ramfb_info);
+}
+
+type_init(virtio_ramfb_register_types)
diff -ru --un qemu-7.2.0/hw/display/virtio-ramfb.h qemu-utm-7.2.0/hw/display/virtio-ramfb.h
--- qemu-7.2.0/hw/display/virtio-ramfb.h	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/hw/display/virtio-ramfb.h	2022-12-26 13:45:03
@@ -0,0 +1,28 @@
+#ifndef VIRTIO_RAMFB_H
+#define VIRTIO_RAMFB_H
+
+#include "hw/virtio/virtio-gpu-pci.h"
+#include "hw/display/ramfb.h"
+#include "qom/object.h"
+
+/*
+ * virtio-ramfb-base: This extends VirtioPCIProxy.
+ */
+#define TYPE_VIRTIO_RAMFB_BASE "virtio-ramfb-base"
+OBJECT_DECLARE_TYPE(VirtIORAMFBBase, VirtIORAMFBBaseClass,
+                    VIRTIO_RAMFB_BASE)
+
+struct VirtIORAMFBBase {
+    VirtIOPCIProxy parent_obj;
+
+    VirtIOGPUBase *vgpu;
+    RAMFBState    *ramfb;
+};
+
+struct VirtIORAMFBBaseClass {
+    VirtioPCIClass parent_class;
+
+    DeviceReset parent_reset;
+};
+
+#endif /* VIRTIO_RAMFB_H */
diff -ru --un qemu-7.2.0/hw/misc/macio/macio.c qemu-utm-7.2.0/hw/misc/macio/macio.c
--- qemu-7.2.0/hw/misc/macio/macio.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/misc/macio/macio.c	2022-12-26 13:45:03
@@ -35,6 +35,7 @@
 #include "hw/misc/macio/macio.h"
 #include "hw/intc/heathrow_pic.h"
 #include "trace.h"
+#include "include/hw/audio/screamer.h"
 
 #define ESCC_CLOCK 3686400
 
@@ -104,7 +105,18 @@
     sysbus_dev = SYS_BUS_DEVICE(&s->dbdma);
     memory_region_add_subregion(&s->bar, 0x08000,
                                 sysbus_mmio_get_region(sysbus_dev, 0));
+    if (!qdev_realize(DEVICE(&s->screamer), BUS(&s->macio_bus), errp)) {
+        return;
+    }
 
+    /* Add the screamer sound chip */
+    sysbus_dev = SYS_BUS_DEVICE(&s->screamer);
+    const int offset = 0x14000; /* Offset from base address register (bar) */
+    const int region_number = 0; /* which memory region to use */
+    memory_region_add_subregion(&s->bar, offset,
+                                sysbus_mmio_get_region(sysbus_dev,
+                                                       region_number));
+
     qdev_prop_set_uint32(DEVICE(&s->escc), "disabled", 0);
     qdev_prop_set_uint32(DEVICE(&s->escc), "frequency", ESCC_CLOCK);
     qdev_prop_set_uint32(DEVICE(&s->escc), "it_shift", 4);
@@ -364,6 +376,19 @@
         memory_region_add_subregion(&s->bar, 0x16000,
                                     sysbus_mmio_get_region(sysbus_dev, 0));
     }
+
+    /* Screamer Sound Chip */
+    const int gpio_0 = 0;
+    const int gpio_1 = 1;
+    const int transmit_channel = 0x10;
+    const int receive_channel = 0x12;
+    sysbus_dev = SYS_BUS_DEVICE(&s->screamer);
+    sysbus_connect_irq(sysbus_dev, gpio_0, qdev_get_gpio_in(pic_dev,
+                                           NEWWORLD_SCREAMER_IRQ));
+    sysbus_connect_irq(sysbus_dev, gpio_1, qdev_get_gpio_in(pic_dev,
+                                           NEWWORLD_SCREAMER_DMA_IRQ));
+    screamer_register_dma_functions(SCREAMER(sysbus_dev), &s->dbdma,
+                                    transmit_channel, receive_channel);
 }
 
 static void macio_newworld_init(Object *obj)
@@ -393,6 +418,9 @@
     object_initialize_child(OBJECT(s), "dbdma", &s->dbdma, TYPE_MAC_DBDMA);
 
     object_initialize_child(OBJECT(s), "escc", &s->escc, TYPE_ESCC);
+
+    object_initialize_child(OBJECT(s), SOUND_CHIP_NAME, &s->screamer,
+                            TYPE_SCREAMER);
 }
 
 static const VMStateDescription vmstate_macio_oldworld = {
diff -ru --un qemu-7.2.0/hw/ppc/Kconfig qemu-utm-7.2.0/hw/ppc/Kconfig
--- qemu-7.2.0/hw/ppc/Kconfig	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/ppc/Kconfig	2022-12-26 13:45:03
@@ -117,6 +117,7 @@
     select MAC_PMU
     select UNIN_PCI
     select FW_CFG_PPC
+    select SCREAMER
 
 config E500
     bool
diff -ru --un qemu-7.2.0/hw/usb/redirect.c qemu-utm-7.2.0/hw/usb/redirect.c
--- qemu-7.2.0/hw/usb/redirect.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/hw/usb/redirect.c	2022-12-26 13:45:03
@@ -1280,7 +1280,8 @@
     }
 #endif
 
-    if (runstate_check(RUN_STATE_INMIGRATE)) {
+    if (runstate_check(RUN_STATE_INMIGRATE) ||
+        runstate_check(RUN_STATE_RESTORE_VM)) {
         flags |= usbredirparser_fl_no_hello;
     }
     usbredirparser_init(dev->parser, VERSION, caps, USB_REDIR_CAPS_SIZE,
diff -ru --un qemu-7.2.0/include/disas/dis-asm.h qemu-utm-7.2.0/include/disas/dis-asm.h
--- qemu-7.2.0/include/disas/dis-asm.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/disas/dis-asm.h	2022-12-26 13:45:03
@@ -416,6 +416,7 @@
 typedef int (*disassembler_ftype) (bfd_vma, disassemble_info *);
 
 int print_insn_tci(bfd_vma, disassemble_info*);
+int print_insn_tcti(bfd_vma, disassemble_info*);
 int print_insn_big_mips         (bfd_vma, disassemble_info*);
 int print_insn_little_mips      (bfd_vma, disassemble_info*);
 int print_insn_nanomips         (bfd_vma, disassemble_info*);
diff -ru --un qemu-7.2.0/include/exec/exec-all.h qemu-utm-7.2.0/include/exec/exec-all.h
--- qemu-7.2.0/include/exec/exec-all.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/exec/exec-all.h	2022-12-26 13:45:03
@@ -657,7 +657,11 @@
 #if defined(CONFIG_TCG_INTERPRETER)
 extern __thread uintptr_t tci_tb_ptr;
 # define GETPC() tci_tb_ptr
+#elif defined(CONFIG_TCG_THREADED_INTERPRETER)
+extern __thread uintptr_t tcti_call_return_address;
+# define GETPC() tcti_call_return_address
 #else
+/* Note that this is correct for TCTI also; whose gadget behaves like native code. */
 # define GETPC() \
     ((uintptr_t)__builtin_extract_return_addr(__builtin_return_address(0)))
 #endif
diff -ru --un qemu-7.2.0/include/hw/audio/screamer.h qemu-utm-7.2.0/include/hw/audio/screamer.h
--- qemu-7.2.0/include/hw/audio/screamer.h	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/include/hw/audio/screamer.h	2022-12-26 13:45:03
@@ -0,0 +1,42 @@
+/*
+ * File: screamer.h
+ * Description: header file to the hw/audio/screamer.c file
+ */
+
+#ifndef screamer_h
+#define screamer_h
+
+#include <inttypes.h>
+#include "audio/audio.h"
+#include "hw/ppc/mac_dbdma.h"
+
+#define TYPE_SCREAMER "screamer"
+#define SCREAMER(obj) OBJECT_CHECK(ScreamerState, (obj), TYPE_SCREAMER)
+#define SOUND_CHIP_NAME "Screamer Sound Chip"
+#define MAX_BUFFER_SIZE (128 * 64)
+
+typedef struct ScreamerState {
+    SysBusDevice parent_obj;
+    uint16_t awacs[8]; /* Shadow/awacs registers */
+    uint32_t sound_control;
+    uint32_t codec_control;
+    uint32_t codec_status;
+    uint32_t clip_count;
+    uint32_t byte_swap;
+    uint32_t frame_count;
+    SWVoiceOut *speaker_voice;
+    DBDMAState *dbdma;
+    qemu_irq dma_send_irq;
+    qemu_irq dma_receive_irq;
+    qemu_irq irq;
+    QEMUSoundCard card;
+    MemoryRegion io_memory_region;
+    uint8_t spk_buffer[MAX_BUFFER_SIZE];
+    uint16_t spk_buffer_position, spk_play_position;
+    DBDMA_io dma_io;
+} ScreamerState;
+
+void screamer_register_dma_functions(ScreamerState *s, void *dbdma,
+                                     int send_channel, int receive_channel);
+
+#endif /* screamer_h */
diff -ru --un qemu-7.2.0/include/hw/misc/macio/macio.h qemu-utm-7.2.0/include/hw/misc/macio/macio.h
--- qemu-7.2.0/include/hw/misc/macio/macio.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/hw/misc/macio/macio.h	2022-12-26 13:45:03
@@ -36,6 +36,7 @@
 #include "hw/nvram/mac_nvram.h"
 #include "hw/ppc/mac_dbdma.h"
 #include "hw/ppc/openpic.h"
+#include "hw/audio/screamer.h"
 #include "qom/object.h"
 
 /* Old World IRQs */
@@ -58,6 +59,9 @@
 #define NEWWORLD_IDE1_DMA_IRQ  0x3
 #define NEWWORLD_EXTING_GPIO1  0x2f
 #define NEWWORLD_EXTING_GPIO9  0x37
+#define NEWWORLD_SCREAMER_IRQ  0x18
+#define NEWWORLD_SCREAMER_DMA_IRQ 0x9
+#define NEWWORLD_SCREAMER_RX_IRQ 0xa
 
 /* MacIO virtual bus */
 #define TYPE_MACIO_BUS "macio-bus"
@@ -109,6 +113,7 @@
     PMUState pmu;
     DBDMAState dbdma;
     ESCCState escc;
+    ScreamerState screamer;
     uint64_t frequency;
 };
 
diff -ru --un qemu-7.2.0/include/qemu/osdep.h qemu-utm-7.2.0/include/qemu/osdep.h
--- qemu-7.2.0/include/qemu/osdep.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/qemu/osdep.h	2022-12-26 13:45:03
@@ -673,26 +673,6 @@
  */
 size_t qemu_get_host_physmem(void);
 
-/*
- * Toggle write/execute on the pages marked MAP_JIT
- * for the current thread.
- */
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
-static inline void qemu_thread_jit_execute(void)
-{
-    pthread_jit_write_protect_np(true);
-}
-
-static inline void qemu_thread_jit_write(void)
-{
-    pthread_jit_write_protect_np(false);
-}
-#else
-static inline void qemu_thread_jit_write(void) {}
-static inline void qemu_thread_jit_execute(void) {}
-#endif
-
 /**
  * Platforms which do not support system() return ENOSYS
  */
diff -ru --un qemu-7.2.0/include/tcg/tcg-apple-jit.h qemu-utm-7.2.0/include/tcg/tcg-apple-jit.h
--- qemu-7.2.0/include/tcg/tcg-apple-jit.h	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/include/tcg/tcg-apple-jit.h	2022-12-26 13:45:03
@@ -0,0 +1,100 @@
+/*
+ * Apple Silicon functions for JIT handling
+ *
+ * Copyright (c) 2020 osy
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TCG_APPLE_JIT_H
+#define TCG_APPLE_JIT_H
+
+/*
+ * APRR handling
+ * Credits to: https://siguza.github.io/APRR/
+ * Reversed from /usr/lib/system/libsystem_pthread.dylib
+ */
+
+#if defined(__aarch64__) && defined(CONFIG_DARWIN)
+
+#define _COMM_PAGE_START_ADDRESS        (0x0000000FFFFFC000ULL) /* In TTBR0 */
+#define _COMM_PAGE_APRR_SUPPORT         (_COMM_PAGE_START_ADDRESS + 0x10C)
+#define _COMM_PAGE_APPR_WRITE_ENABLE    (_COMM_PAGE_START_ADDRESS + 0x110)
+#define _COMM_PAGE_APRR_WRITE_DISABLE   (_COMM_PAGE_START_ADDRESS + 0x118)
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    return aprr_support > 0;
+}
+
+/* write protect enable = write disable */
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+    /* Access shared kernel page at fixed memory location. */
+    uint8_t aprr_support = *(volatile uint8_t *)_COMM_PAGE_APRR_SUPPORT;
+    if (aprr_support == 0 || aprr_support > 3) {
+        return;
+    } else if (aprr_support == 1) {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_4_c15_c2_7, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    } else {
+        __asm__ __volatile__ (
+            "mov x0, %0\n"
+            "ldr x0, [x0]\n"
+            "msr S3_6_c15_c1_5, x0\n"
+            "isb sy\n"
+            :: "r" (enabled ? _COMM_PAGE_APRR_WRITE_DISABLE
+                            : _COMM_PAGE_APPR_WRITE_ENABLE)
+            : "memory", "x0"
+        );
+    }
+}
+
+#else /* defined(__aarch64__) && defined(CONFIG_DARWIN) */
+
+static __attribute__((__always_inline__)) bool jit_write_protect_supported(void)
+{
+    return false;
+}
+
+static __attribute__((__always_inline__)) void jit_write_protect(int enabled)
+{
+}
+
+#endif
+
+static inline void qemu_thread_jit_execute(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(true);
+    }
+}
+
+static inline void qemu_thread_jit_write(void)
+{
+    if (jit_write_protect_supported()) {
+        jit_write_protect(false);
+    }
+}
+
+#endif /* define TCG_APPLE_JIT_H */
diff -ru --un qemu-7.2.0/include/tcg/tcg-opc.h qemu-utm-7.2.0/include/tcg/tcg-opc.h
--- qemu-7.2.0/include/tcg/tcg-opc.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/tcg/tcg-opc.h	2022-12-26 13:45:03
@@ -194,7 +194,11 @@
     TCG_OPF_NOT_PRESENT)
 DEF(exit_tb, 0, 0, 1, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
 DEF(goto_tb, 0, 0, 1, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+DEF(goto_ptr, 0, 1, 0, TCG_OPF_BB_EXIT | TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT)
+#else
 DEF(goto_ptr, 0, 1, 0, TCG_OPF_BB_EXIT | TCG_OPF_BB_END)
+#endif
 
 DEF(plugin_cb_start, 0, 0, 3, TCG_OPF_NOT_PRESENT)
 DEF(plugin_cb_end, 0, 0, 0, TCG_OPF_NOT_PRESENT)
diff -ru --un qemu-7.2.0/include/tcg/tcg.h qemu-utm-7.2.0/include/tcg/tcg.h
--- qemu-7.2.0/include/tcg/tcg.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/tcg/tcg.h	2022-12-26 13:45:03
@@ -1199,7 +1199,7 @@
 #define TB_EXIT_IDXMAX    1
 #define TB_EXIT_REQUESTED 3
 
-#ifdef CONFIG_TCG_INTERPRETER
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
 uintptr_t tcg_qemu_tb_exec(CPUArchState *env, const void *tb_ptr);
 #else
 typedef uintptr_t tcg_prologue_fn(CPUArchState *env, const void *tb_ptr);
diff -ru --un qemu-7.2.0/include/ui/cocoa.h qemu-utm-7.2.0/include/ui/cocoa.h
--- qemu-7.2.0/include/ui/cocoa.h	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/include/ui/cocoa.h	2022-12-26 13:45:03
@@ -0,0 +1,141 @@
+/*
+ * QEMU Cocoa CG display driver
+ *
+ * Copyright (c) 2008 Mike Kronenberg
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef UI_COCOA_H
+#define UI_COCOA_H
+
+#import <Cocoa/Cocoa.h>
+
+#include "ui/clipboard.h"
+#include "ui/console.h"
+#include "ui/kbd-state.h"
+#include "qemu/main-loop.h"
+#include "qemu/thread.h"
+
+//#define DEBUG
+
+#ifdef DEBUG
+#define COCOA_DEBUG(...)  { (void) fprintf (stdout, __VA_ARGS__); }
+#else
+#define COCOA_DEBUG(...)  ((void) 0)
+#endif
+
+typedef struct CocoaListener {
+    DisplayChangeListener dcl;
+    QEMUCursor *cursor;
+    int mouse_x;
+    int mouse_y;
+    int mouse_on;
+#ifdef CONFIG_OPENGL
+    uint32_t gl_scanout_id;
+    DisplayGLTextureBorrower gl_scanout_borrow;
+    bool gl_scanout_y0_top;
+#endif
+} CocoaListener;
+
+typedef struct {
+    CocoaListener *active_listener;
+    CocoaListener *listeners;
+    size_t listeners_count;
+    DisplaySurface *surface;
+    QemuMutex draw_mutex;
+    QKbdState *kbd;
+    CGImageRef cursor_cgimage;
+    int cursor_show;
+    bool left_command_key_disabled;
+    bool swap_opt_cmd;
+    bool inited;
+} QEMUScreen;
+
+typedef struct {
+    QemuClipboardInfo *info;
+    QemuEvent event;
+} QemuCocoaClipboard;
+
+@interface QemuCocoaView : NSView
+{
+    NSTextField *pauseLabel;
+    NSTrackingArea *trackingArea;
+    QEMUScreen *screen;
+    int screen_width;
+    int screen_height;
+    BOOL isMouseGrabbed;
+    BOOL isAbsoluteEnabled;
+    CFMachPortRef eventsTap;
+}
+- (id)initWithFrame:(NSRect)frameRect
+             screen:(QEMUScreen *)given_screen;
+- (void) frameUpdated;
+- (void) selectConsoleLocked:(unsigned int)index;
+- (NSSize) computeUnzoomedSize;
+- (NSSize) fixZoomedFullScreenSize:(NSSize)proposedSize;
+- (void) resizeWindow;
+- (void) updateUIInfo;
+- (void) updateScreenWidth:(int)w height:(int)h;
+- (void) grabMouse;
+- (void) ungrabMouse;
+- (void) setFullGrab:(id)sender;
+- (bool) handleEvent:(NSEvent *)event;
+- (void) setAbsoluteEnabled:(BOOL)tIsAbsoluteEnabled;
+/* The state surrounding mouse grabbing is potentially confusing.
+ * isAbsoluteEnabled tracks qemu_input_is_absolute() [ie "is the emulated
+ *   pointing device an absolute-position one?"], but is only updated on
+ *   next refresh.
+ * isMouseGrabbed tracks whether GUI events are directed to the guest;
+ *   it controls whether special keys like Cmd get sent to the guest,
+ *   and whether we capture the mouse when in non-absolute mode.
+ */
+- (BOOL) isMouseGrabbed;
+- (BOOL) isAbsoluteEnabled;
+- (void) setNeedsDisplayForCursorX:(int)x
+                                 y:(int)y
+                             width:(int)width
+                            height:(int)height
+                      screenHeight:(int)screen_height;
+- (void)displayPause;
+- (void)removePause;
+@end
+
+@interface QemuCocoaAppController : NSObject
+                                       <NSWindowDelegate, NSApplicationDelegate>
+{
+    QemuCocoaView *cocoaView;
+}
+- (id) initWithScreen:(QEMUScreen *)screen;
+- (QemuCocoaView *)cocoaView;
+@end
+
+@interface QemuCocoaPasteboardTypeOwner : NSObject<NSPasteboardTypeOwner>
+{
+    QemuCocoaClipboard *cb;
+}
+- (id) initWith:(QemuCocoaClipboard *)aCb;
+@end
+
+void cocoa_listener_select(size_t index);
+
+typedef void (^CodeBlock)(void);
+typedef bool (^BoolCodeBlock)(void);
+
+#endif
diff -ru --un qemu-7.2.0/include/ui/console.h qemu-utm-7.2.0/include/ui/console.h
--- qemu-7.2.0/include/ui/console.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/ui/console.h	2022-12-26 13:45:03
@@ -109,11 +108,13 @@
 #define QEMU_ALLOCATED_FLAG     0x01
 #define QEMU_PLACEHOLDER_FLAG   0x02
 
+typedef uint32_t (* DisplayGLTextureBorrower)(uint32_t id, bool *y_0_top,
+                                              uint32_t *width,
+                                              uint32_t *height);
+
 typedef struct ScanoutTexture {
     uint32_t backing_id;
-    bool backing_y_0_top;
-    uint32_t backing_width;
-    uint32_t backing_height;
+    DisplayGLTextureBorrower backing_borrow;
     uint32_t x;
     uint32_t y;
     uint32_t width;
@@ -128,6 +129,7 @@
     GLenum glformat;
     GLenum gltype;
     GLuint texture;
+    bool   glswapped;
 #endif
 } DisplaySurface;
 
@@ -248,9 +250,7 @@
     /* required if GL */
     void (*dpy_gl_scanout_texture)(DisplayChangeListener *dcl,
                                    uint32_t backing_id,
-                                   bool backing_y_0_top,
-                                   uint32_t backing_width,
-                                   uint32_t backing_height,
+                                   DisplayGLTextureBorrower backing_borrow,
                                    uint32_t x, uint32_t y,
                                    uint32_t w, uint32_t h);
     /* optional (default to true if has dpy_gl_scanout_dmabuf) */
@@ -353,9 +353,8 @@
                           pixman_format_code_t format);
 
 void dpy_gl_scanout_disable(QemuConsole *con);
-void dpy_gl_scanout_texture(QemuConsole *con,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
+void dpy_gl_scanout_texture(QemuConsole *con, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y, uint32_t w, uint32_t h);
 void dpy_gl_scanout_dmabuf(QemuConsole *con,
                            QemuDmaBuf *dmabuf);
@@ -455,6 +454,7 @@
 
 void qemu_console_set_display_gl_ctx(QemuConsole *con, DisplayGLCtx *ctx);
 
+QemuConsole *qemu_console_lookup_first_graphic_console(void);
 QemuConsole *qemu_console_lookup_by_index(unsigned int index);
 QemuConsole *qemu_console_lookup_by_device(DeviceState *dev, uint32_t head);
 QemuConsole *qemu_console_lookup_by_device_name(const char *device_id,
 
diff -ru --un qemu-7.2.0/include/ui/egl-helpers.h qemu-utm-7.2.0/include/ui/egl-helpers.h
--- qemu-7.2.0/include/ui/egl-helpers.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/ui/egl-helpers.h	2022-12-26 13:45:03
@@ -6,6 +6,9 @@
 #ifdef CONFIG_GBM
 #include <gbm.h>
 #endif
+#ifdef CONFIG_ANGLE
+#include <EGL/eglext_angle.h>
+#endif
 #include "ui/console.h"
 #include "ui/shader.h"
 
@@ -17,6 +20,7 @@
     int width;
     int height;
     GLuint texture;
+    GLenum texture_target;
     GLuint framebuffer;
     bool delete_texture;
     QemuDmaBuf *dmabuf;
@@ -24,15 +28,18 @@
 
 void egl_fb_destroy(egl_fb *fb);
 void egl_fb_setup_default(egl_fb *fb, int width, int height);
+void egl_fb_setup_for_tex_target(egl_fb *fb, int width, int height,
+                                 GLuint texture, GLenum target, bool delete);
 void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
                           GLuint texture, bool delete);
+void egl_fb_setup_new_tex_target(egl_fb *fb, int width, int height, GLenum target);
 void egl_fb_setup_new_tex(egl_fb *fb, int width, int height);
 void egl_fb_blit(egl_fb *dst, egl_fb *src, bool flip);
 void egl_fb_read(DisplaySurface *dst, egl_fb *src);
 
-void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip);
+void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip, bool swap);
 void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
-                       int x, int y, double scale_x, double scale_y);
+                       bool swap, int x, int y, double scale_x, double scale_y);
 
 #ifdef CONFIG_GBM
 
@@ -51,12 +58,24 @@
 
 #endif
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win);
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win);
+EGLSurface qemu_egl_init_buffer_surface(EGLContext ectx, EGLenum buftype,
+                                        EGLClientBuffer buffer, const EGLint *attrib_list);
+bool qemu_egl_destroy_surface(EGLSurface surface);
 
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode);
+int qemu_egl_init_dpy_surfaceless(DisplayGLMode mode);
+
 #if defined(CONFIG_X11) || defined(CONFIG_GBM)
 
 int qemu_egl_init_dpy_x11(EGLNativeDisplayType dpy, DisplayGLMode mode);
 int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode);
+
+#endif
+
+#if defined(CONFIG_ANGLE)
+
+int qemu_egl_init_dpy_angle(DisplayGLMode mode);
 
 #endif
 
diff -ru --un qemu-7.2.0/include/ui/gtk.h qemu-utm-7.2.0/include/ui/gtk.h
--- qemu-7.2.0/include/ui/gtk.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/ui/gtk.h	2022-12-26 13:45:03
@@ -171,9 +171,7 @@
 void gd_egl_scanout_disable(DisplayChangeListener *dcl);
 void gd_egl_scanout_texture(DisplayChangeListener *dcl,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
                             uint32_t w, uint32_t h);
 void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
@@ -207,9 +205,7 @@
                                QemuDmaBuf *dmabuf);
 void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
                                 uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
+                                DisplayGLTextureBorrower backing_borrow,
                                 uint32_t x, uint32_t y,
                                 uint32_t w, uint32_t h);
 void gd_gl_area_scanout_disable(DisplayChangeListener *dcl);
diff -ru --un qemu-7.2.0/include/ui/sdl2.h qemu-utm-7.2.0/include/ui/sdl2.h
--- qemu-7.2.0/include/ui/sdl2.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/ui/sdl2.h	2022-12-26 13:45:03
@@ -22,7 +22,7 @@
 #endif
 
 #include "ui/kbd-state.h"
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
 # include "ui/egl-helpers.h"
 #endif
 
@@ -44,7 +44,7 @@
     int ignore_hotkeys;
     SDL_GLContext winctx;
     QKbdState *kbd;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
     QemuGLShader *gls;
     egl_fb guest_fb;
     egl_fb win_fb;
@@ -86,9 +86,7 @@
 void sdl2_gl_scanout_disable(DisplayChangeListener *dcl);
 void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
                              uint32_t w, uint32_t h);
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
diff -ru --un qemu-7.2.0/include/ui/shader.h qemu-utm-7.2.0/include/ui/shader.h
--- qemu-7.2.0/include/ui/shader.h	2022-12-14 11:28:44
+++ qemu-utm-7.2.0/include/ui/shader.h	2022-12-26 13:45:03
@@ -5,7 +5,7 @@
 
 typedef struct QemuGLShader QemuGLShader;
 
-void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip);
+void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip, bool swapped);
 
 QemuGLShader *qemu_gl_init_shader(void);
 void qemu_gl_fini_shader(QemuGLShader *gls);
diff -ru --un qemu-7.2.0/include/ui/spice-display.h qemu-utm-7.2.0/include/ui/spice-display.h
--- qemu-7.2.0/include/ui/spice-display.h	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/include/ui/spice-display.h	2022-12-26 13:45:03
@@ -27,7 +27,12 @@
 #include "ui/qemu-pixman.h"
 #include "ui/console.h"
 
-#if defined(CONFIG_OPENGL) && defined(CONFIG_GBM)
+#if defined(CONFIG_IOSURFACE)
+#include <CoreFoundation/CoreFoundation.h>
+#include <IOSurface/IOSurfaceRef.h>
+#endif
+
+#if defined(CONFIG_OPENGL)
 # if SPICE_SERVER_VERSION >= 0x000d01 /* release 0.13.1 */
 #  define HAVE_SPICE_GL 1
 #  include "ui/egl-helpers.h"
@@ -127,8 +132,20 @@
     bool have_scanout;
     bool have_surface;
 
+#if defined(CONFIG_GBM)
     QemuDmaBuf *guest_dmabuf;
     bool guest_dmabuf_refresh;
+#endif
+#if defined(CONFIG_IOSURFACE)
+    IOSurfaceRef iosurface;
+    int surface_send_fd;
+#endif
+#if defined(CONFIG_ANGLE)
+    EGLSurface esurface;
+    egl_fb iosurface_fb;
+    DisplayGLTextureBorrower backing_borrow;
+    uint32_t backing_id;
+#endif
     bool render_cursor;
 
     egl_fb guest_fb;
diff -ru --un qemu-7.2.0/meson.build qemu-utm-7.2.0/meson.build
--- qemu-7.2.0/meson.build	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/meson.build	2022-12-26 13:45:03
@@ -50,6 +50,7 @@
 supported_oses = ['windows', 'freebsd', 'netbsd', 'openbsd', 'darwin', 'sunos', 'linux']
 supported_cpus = ['ppc', 'ppc64', 's390x', 'riscv', 'x86', 'x86_64',
   'arm', 'aarch64', 'loongarch64', 'mips', 'mips64', 'sparc64']
+tcti_supported_cpus = ['aarch64']
 
 cpu = host_machine.cpu_family()
 
@@ -381,6 +382,7 @@
 version_res = []
 coref = []
 iokit = []
+iosurface = not_found
 emulator_link_args = []
 nvmm =not_found
 hvf = not_found
@@ -403,6 +405,7 @@
 elif targetos == 'darwin'
   coref = dependency('appleframeworks', modules: 'CoreFoundation')
   iokit = dependency('appleframeworks', modules: 'IOKit', required: false)
+  iosurface = dependency('appleframeworks', modules: 'IOSurface', required: false)
   host_dsosuf = '.dylib'
 elif targetos == 'sunos'
   socket = [cc.find_library('socket'),
@@ -469,6 +472,24 @@
   endif
   if get_option('tcg_interpreter')
     tcg_arch = 'tci'
+  elif get_option('tcg_threaded_interpreter')
+    if cpu not in tcti_supported_cpus
+      error('Unsupported CPU @0@ for TCTI, try --enable-tcg-interpreter'.format(cpu))
+    else
+      warning('TCTI is extremely experimental and incomplete! Things might break!')
+      tcg_arch = '@0@-tcti'.format(cpu)
+    endif
+
+    # Tell our compiler how to generate our TCTI gadgets.
+    gadget_generator = 'tcg/@0@/tcti-gadget-gen.py'.format(tcg_arch)
+    tcti_gadgets = custom_target('tcti-gadgets.c.inc',
+                                output: 'tcti-gadgets.c.inc',
+                                input: gadget_generator,
+                                command: [find_program(gadget_generator), '@OUTPUT@'],
+                                build_by_default: true,
+                                build_always_stale: false)
+
+    genh += tcti_gadgets
   elif host_arch == 'x86_64'
     tcg_arch = 'i386'
   elif host_arch == 'ppc64'
@@ -1914,6 +1935,7 @@
 config_host_data.set('CONFIG_X11', x11.found())
 config_host_data.set('CONFIG_DBUS_DISPLAY', dbus_display)
 config_host_data.set('CONFIG_CFI', get_option('cfi'))
+config_host_data.set('CONFIG_IOSURFACE', iosurface.found())
 config_host_data.set('CONFIG_SELINUX', selinux.found())
 config_host_data.set('CONFIG_XEN_BACKEND', xen.found())
 if xen.found()
@@ -1955,6 +1977,7 @@
 config_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))
 config_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))
 config_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))
+config_host_data.set('CONFIG_ANGLE', cc.has_header('EGL/eglext_angle.h'))
 if targetos == 'windows'
   config_host_data.set('HAVE_AFUNIX_H', cc.has_header('afunix.h'))
 endif
@@ -2547,6 +2570,8 @@
       config_all += { sym: 'y' }
       if sym == 'CONFIG_TCG' and tcg_arch == 'tci'
         config_target += { 'CONFIG_TCG_INTERPRETER': 'y' }
+      elif sym == 'CONFIG_TCG' and tcg_arch.endswith('tcti')
+        config_target += { 'CONFIG_TCG_THREADED_INTERPRETER': 'y' }
       endif
       if target in modular_tcg
         config_target += { 'CONFIG_TCG_MODULAR': 'y' }
@@ -2766,9 +2791,18 @@
   error('fdt not available but required by targets ' + ', '.join(fdt_required))
 endif
 
+ucontext = dependency('libucontext', kwargs: static_kwargs, required : false)
+if not ucontext.found() and get_option('ucontext').enabled()
+  libucontext_proj = subproject('libucontext',
+                                default_options: ['default_library=static',
+                                                  'freestanding=true'])
+  ucontext = libucontext_proj.get_variable('libucontext_dep')
+endif
+
 config_host_data.set('CONFIG_CAPSTONE', capstone.found())
 config_host_data.set('CONFIG_FDT', fdt.found())
 config_host_data.set('CONFIG_SLIRP', slirp.found())
+config_host_data.set('CONFIG_LIBUCONTEXT', ucontext.found())
 
 #####################
 # Generated sources #
@@ -3049,7 +3083,7 @@
 util_ss = util_ss.apply(config_all, strict: false)
 libqemuutil = static_library('qemuutil',
                              sources: util_ss.sources() + stub_ss.sources() + genh,
-                             dependencies: [util_ss.dependencies(), libm, threads, glib, socket, malloc, pixman])
+                             dependencies: [util_ss.dependencies(), libm, threads, glib, socket, malloc, pixman, ucontext])
 qemuutil = declare_dependency(link_with: libqemuutil,
                               sources: genh + version_res,
                               dependencies: [event_loop_base])
@@ -3462,14 +3496,32 @@
   arch_srcs += target_specific.sources()
   arch_deps += target_specific.dependencies()
 
-  lib = static_library('qemu-' + target,
+  if config_all.has_key('CONFIG_SHARED_LIBRARY_BUILD')
+    build_lib_args = {
+      'target_type': 'shared_library',
+      'install': true,
+      'dependencies': arch_deps + deps,
+      'link_language': link_language,
+      'link_depends': [block_syms, qemu_syms],
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,-U,_qemu_main']),
+      'gnu_symbol_visibility': 'default'
+    }
+  else
+    build_lib_args = {
+      'target_type': 'static_library',
+      'install': false,
+      'dependencies': arch_deps,
+      'name_suffix': 'fa'
+    }
+  endif
+
+  lib = build_target('qemu-' + target,
                  sources: arch_srcs + genh,
-                 dependencies: arch_deps,
                  objects: objects,
                  include_directories: target_inc,
                  c_args: c_args,
                  build_by_default: false,
-                 name_suffix: 'fa')
+                 kwargs: build_lib_args)
 
   if target.endswith('-softmmu')
     execs = [{
@@ -3503,6 +3555,17 @@
       'dependencies': []
     }]
   endif
+  if config_all.has_key('CONFIG_SHARED_LIBRARY_BUILD')
+    build_exe_args = {
+      'link_with': lib,
+      'link_args': link_args + cc.get_supported_link_arguments(['-Wl,--exclude-libs,ALL'])
+    }
+  else
+    build_exe_args = {
+      'objects': lib.extract_all_objects(recursive: true),
+      'link_args': link_args
+    }
+  endif
   foreach exe: execs
     exe_name = exe['name']
     if targetos == 'darwin'
@@ -3513,11 +3576,10 @@
                install: true,
                c_args: c_args,
                dependencies: arch_deps + deps + exe['dependencies'],
-               objects: lib.extract_all_objects(recursive: true),
                link_language: link_language,
                link_depends: [block_syms, qemu_syms] + exe.get('link_depends', []),
-               link_args: link_args,
-               win_subsystem: exe['win_subsystem'])
+               win_subsystem: exe['win_subsystem'],
+               kwargs: build_exe_args)
 
     if targetos == 'darwin'
       icon = 'pc-bios/qemu.rsrc'
@@ -3588,6 +3650,10 @@
 endif
 
 if have_tools
+  if config_all.has_key('CONFIG_SHARED_LIBRARY_BUILD')
+    qemu_img_lib = shared_library('qemu-img', [files('qemu-img.c'), hxdep],
+             dependencies: [authz, block, crypto, io, qom, qemuutil], install: true)
+  endif
   qemu_img = executable('qemu-img', [files('qemu-img.c'), hxdep],
              dependencies: [authz, block, crypto, io, qom, qemuutil], install: true)
   qemu_io = executable('qemu-io', files('qemu-io.c'),
@@ -3689,6 +3755,7 @@
 summary_info += {'Doc directory':     get_option('prefix') / get_option('docdir')}
 summary_info += {'Build directory':   meson.current_build_dir()}
 summary_info += {'Source path':       meson.current_source_dir()}
+summary_info += {'build shared lib':  config_all.has_key('CONFIG_SHARED_LIBRARY_BUILD')}
 summary_info += {'GIT submodules':    config_host['GIT_SUBMODULES']}
 summary(summary_info, bool_yn: true, section: 'Directories')
 
@@ -3833,6 +3900,8 @@
 if config_all.has_key('CONFIG_TCG')
   if get_option('tcg_interpreter')
     summary_info += {'TCG backend':   'TCI (TCG with bytecode interpreter, slow)'}
+  elif get_option('tcg_threaded_interpreter')
+    summary_info += {'TCG backend':   'TCTI (TCG with threaded-dispatch bytecode interpreter, experimental and slow; but faster than TCI)'}
   else
     summary_info += {'TCG backend':   'native (@0@)'.format(cpu)}
   endif
@@ -3849,6 +3918,7 @@
 
 # Block layer
 summary_info = {}
+summary_info += {'libucontext support': ucontext.found()}
 summary_info += {'coroutine backend': config_host['CONFIG_COROUTINE_BACKEND']}
 summary_info += {'coroutine pool':    have_coroutine_pool}
 if have_block
diff -ru --un qemu-7.2.0/meson_options.txt qemu-utm-7.2.0/meson_options.txt
--- qemu-7.2.0/meson_options.txt	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/meson_options.txt	2022-12-26 13:45:03
@@ -82,6 +82,8 @@
        description: 'TCG support')
 option('tcg_interpreter', type: 'boolean', value: false,
        description: 'TCG with bytecode interpreter (slow)')
+option('tcg_threaded_interpreter', type: 'boolean', value: false,
+       description: 'TCG with threaded-dispatch bytecode interpreter (experimental and slow, but less slow than TCI)')
 option('cfi', type: 'boolean', value: false,
        description: 'Control-Flow Integrity (CFI)')
 option('cfi_debug', type: 'boolean', value: false,
@@ -234,6 +236,8 @@
        description: 'FUSE block device export')
 option('fuse_lseek', type : 'feature', value : 'auto',
        description: 'SEEK_HOLE/SEEK_DATA support for FUSE exports')
+option('ucontext', type : 'feature', value : 'disabled',
+       description: 'libucontext support')
 
 option('trace_backends', type: 'array', value: ['log'],
        choices: ['dtrace', 'ftrace', 'log', 'nop', 'simple', 'syslog', 'ust'],
diff -ru --un qemu-7.2.0/net/vmnet-bridged.m qemu-utm-7.2.0/net/vmnet-bridged.m
--- qemu-7.2.0/net/vmnet-bridged.m	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/net/vmnet-bridged.m	2022-12-26 13:45:03
@@ -88,15 +88,16 @@
         return false;
     }
 
-#if !defined(MAC_OS_VERSION_11_0) || \
-    MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_VERSION_11_0
-    if (options->has_isolated) {
-        error_setg(errp,
-                   "vmnet-bridged.isolated feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
+    if (__builtin_available(macOS 11, *)) {
+        // clang requires a true branch
+    } else {
+        if (options->has_isolated) {
+            error_setg(errp,
+                       "vmnet-bridged.isolated feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
     }
-#endif
     return true;
 }
 
@@ -115,12 +116,12 @@
                               vmnet_shared_interface_name_key,
                               options->ifname);
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
-    xpc_dictionary_set_bool(if_desc,
-                            vmnet_enable_isolation_key,
-                            options->isolated);
-#endif
+    if (__builtin_available(macOS 11, *)) {
+        xpc_dictionary_set_bool(if_desc,
+                                vmnet_enable_isolation_key,
+                                options->isolated);
+    }
+
     return if_desc;
 }
 
diff -ru --un qemu-7.2.0/net/vmnet-host.c qemu-utm-7.2.0/net/vmnet-host.c
--- qemu-7.2.0/net/vmnet-host.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/net/vmnet-host.c	2022-12-26 13:45:03
@@ -22,31 +22,29 @@
 {
     const NetdevVmnetHostOptions *options = &(netdev->u.vmnet_host);
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+    if (__builtin_available(macOS 11, *)) {
+        QemuUUID net_uuid;
+        if (options->has_net_uuid &&
+            qemu_uuid_parse(options->net_uuid, &net_uuid) < 0) {
+            error_setg(errp, "Invalid UUID provided in 'net-uuid'");
+            return false;
+        }
+    } else {
+        if (options->has_isolated) {
+            error_setg(errp,
+                       "vmnet-host.isolated feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
 
-    QemuUUID net_uuid;
-    if (options->has_net_uuid &&
-        qemu_uuid_parse(options->net_uuid, &net_uuid) < 0) {
-        error_setg(errp, "Invalid UUID provided in 'net-uuid'");
-        return false;
+        if (options->has_net_uuid) {
+            error_setg(errp,
+                       "vmnet-host.net-uuid feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
     }
-#else
-    if (options->has_isolated) {
-        error_setg(errp,
-                   "vmnet-host.isolated feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
-    }
 
-    if (options->has_net_uuid) {
-        error_setg(errp,
-                   "vmnet-host.net-uuid feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
-    }
-#endif
-
     if ((options->has_start_address ||
          options->has_end_address ||
          options->has_subnet_mask) &&
@@ -71,21 +69,19 @@
                               vmnet_operation_mode_key,
                               VMNET_HOST_MODE);
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
+    if (__builtin_available(macOS 11, *)) {
+        xpc_dictionary_set_bool(if_desc,
+                                vmnet_enable_isolation_key,
+                                options->isolated);
 
-    xpc_dictionary_set_bool(if_desc,
-                            vmnet_enable_isolation_key,
-                            options->isolated);
-
-    QemuUUID net_uuid;
-    if (options->has_net_uuid) {
-        qemu_uuid_parse(options->net_uuid, &net_uuid);
-        xpc_dictionary_set_uuid(if_desc,
-                                vmnet_network_identifier_key,
-                                net_uuid.data);
+        QemuUUID net_uuid;
+        if (options->has_net_uuid) {
+            qemu_uuid_parse(options->net_uuid, &net_uuid);
+            xpc_dictionary_set_uuid(if_desc,
+                                    vmnet_network_identifier_key,
+                                    net_uuid.data);
+        }
     }
-#endif
 
     if (options->has_start_address) {
         xpc_dictionary_set_string(if_desc,
diff -ru --un qemu-7.2.0/net/vmnet-shared.c qemu-utm-7.2.0/net/vmnet-shared.c
--- qemu-7.2.0/net/vmnet-shared.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/net/vmnet-shared.c	2022-12-26 13:45:03
@@ -21,15 +21,16 @@
 {
     const NetdevVmnetSharedOptions *options = &(netdev->u.vmnet_shared);
 
-#if !defined(MAC_OS_VERSION_11_0) || \
-    MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_VERSION_11_0
-    if (options->has_isolated) {
-        error_setg(errp,
-                   "vmnet-shared.isolated feature is "
-                   "unavailable: outdated vmnet.framework API");
-        return false;
+    if (__builtin_available(macOS 11, *)) {
+        // clang requires a true branch
+    } else {
+        if (options->has_isolated) {
+            error_setg(errp,
+                       "vmnet-shared.isolated feature is "
+                       "unavailable: outdated vmnet.framework API");
+            return false;
+        }
     }
-#endif
 
     if ((options->has_start_address ||
          options->has_end_address ||
@@ -76,14 +77,13 @@
                                   options->subnet_mask);
     }
 
-#if defined(MAC_OS_VERSION_11_0) && \
-    MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_VERSION_11_0
-    xpc_dictionary_set_bool(
-        if_desc,
-        vmnet_enable_isolation_key,
-        options->isolated
-    );
-#endif
+    if (__builtin_available(macOS 11, *)) {
+        xpc_dictionary_set_bool(
+            if_desc,
+            vmnet_enable_isolation_key,
+            options->isolated
+        );
+    }
 
     return if_desc;
 }
diff -ru --un qemu-7.2.0/qapi/ui.json qemu-utm-7.2.0/qapi/ui.json
--- qemu-7.2.0/qapi/ui.json	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/qapi/ui.json	2022-12-26 13:45:03
@@ -1371,7 +1371,7 @@
     { 'name': 'gtk', 'if': 'CONFIG_GTK' },
     { 'name': 'sdl', 'if': 'CONFIG_SDL' },
     { 'name': 'egl-headless',
-              'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_GBM'] } },
+              'if': 'CONFIG_OPENGL' },
     { 'name': 'curses', 'if': 'CONFIG_CURSES' },
     { 'name': 'cocoa', 'if': 'CONFIG_COCOA' },
     { 'name': 'spice-app', 'if': 'CONFIG_SPICE' },
@@ -1404,7 +1404,7 @@
       'cocoa': { 'type': 'DisplayCocoa', 'if': 'CONFIG_COCOA' },
       'curses': { 'type': 'DisplayCurses', 'if': 'CONFIG_CURSES' },
       'egl-headless': { 'type': 'DisplayEGLHeadless',
-                        'if': { 'all': ['CONFIG_OPENGL', 'CONFIG_GBM'] } },
+                        'if': 'CONFIG_OPENGL' },
       'dbus': { 'type': 'DisplayDBus', 'if': 'CONFIG_DBUS_DISPLAY' },
       'sdl': { 'type': 'DisplaySDL', 'if': 'CONFIG_SDL' }
   }
diff -ru --un qemu-7.2.0/scripts/meson-buildoptions.sh qemu-utm-7.2.0/scripts/meson-buildoptions.sh
--- qemu-7.2.0/scripts/meson-buildoptions.sh	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/scripts/meson-buildoptions.sh	2022-12-26 13:45:03
@@ -37,6 +37,9 @@
   printf "%s\n" '                           getrandom()'
   printf "%s\n" '  --enable-strip           Strip targets on install'
   printf "%s\n" '  --enable-tcg-interpreter TCG with bytecode interpreter (slow)'
+  printf "%s\n" '  --enable-tcg-threaded-interpreter'
+  printf "%s\n" '                           TCG with threaded-dispatch bytecode interpreter'
+  printf "%s\n" '                           (experimental and slow, but less slow than TCI)'
   printf "%s\n" '  --enable-trace-backends=CHOICES'
   printf "%s\n" '                           Set available tracing backends [log] (choices:'
   printf "%s\n" '                           dtrace/ftrace/log/nop/simple/syslog/ust)'
@@ -153,6 +156,7 @@
   printf "%s\n" '  tools           build support utilities that come with QEMU'
   printf "%s\n" '  tpm             TPM support'
   printf "%s\n" '  u2f             U2F emulation support'
+  printf "%s\n" '  ucontext        libucontext support'
   printf "%s\n" '  usb-redir       libusbredir support'
   printf "%s\n" '  vde             vde network backend support'
   printf "%s\n" '  vdi             vdi image format support'
@@ -414,6 +418,8 @@
     --disable-tcg) printf "%s" -Dtcg=disabled ;;
     --enable-tcg-interpreter) printf "%s" -Dtcg_interpreter=true ;;
     --disable-tcg-interpreter) printf "%s" -Dtcg_interpreter=false ;;
+    --enable-tcg-threaded-interpreter) printf "%s" -Dtcg_threaded_interpreter=true ;;
+    --disable-tcg-threaded-interpreter) printf "%s" -Dtcg_threaded_interpreter=false ;;
     --tls-priority=*) quote_sh "-Dtls_priority=$2" ;;
     --enable-tools) printf "%s" -Dtools=enabled ;;
     --disable-tools) printf "%s" -Dtools=disabled ;;
@@ -423,6 +429,8 @@
     --with-trace-file=*) quote_sh "-Dtrace_file=$2" ;;
     --enable-u2f) printf "%s" -Du2f=enabled ;;
     --disable-u2f) printf "%s" -Du2f=disabled ;;
+    --enable-ucontext) printf "%s" -Ducontext=enabled ;;
+    --disable-ucontext) printf "%s" -Ducontext=disabled ;;
     --enable-usb-redir) printf "%s" -Dusb_redir=enabled ;;
     --disable-usb-redir) printf "%s" -Dusb_redir=disabled ;;
     --enable-vde) printf "%s" -Dvde=enabled ;;
diff -ru --un qemu-7.2.0/softmmu/runstate.c qemu-utm-7.2.0/softmmu/runstate.c
--- qemu-7.2.0/softmmu/runstate.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/softmmu/runstate.c	2022-12-26 13:45:03
@@ -76,6 +76,7 @@
 
 static const RunStateTransition runstate_transitions_def[] = {
     { RUN_STATE_PRELAUNCH, RUN_STATE_INMIGRATE },
+    { RUN_STATE_PRELAUNCH, RUN_STATE_RESTORE_VM },
 
     { RUN_STATE_DEBUG, RUN_STATE_RUNNING },
     { RUN_STATE_DEBUG, RUN_STATE_FINISH_MIGRATE },
diff -ru --un qemu-7.2.0/softmmu/vl.c qemu-utm-7.2.0/softmmu/vl.c
--- qemu-7.2.0/softmmu/vl.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/softmmu/vl.c	2022-12-26 13:45:03
@@ -2636,6 +2636,10 @@
     bool userconfig = true;
     FILE *vmstate_dump_file = NULL;
 
+    /* in non-library builds this is done in a constructor */
+#ifdef CONFIG_SHARED_LIBRARY_BUILD
+    rcu_register_thread();
+#endif
     qemu_add_opts(&qemu_drive_opts);
     qemu_add_drive_opts(&qemu_legacy_drive_opts);
     qemu_add_drive_opts(&qemu_common_drive_opts);
@@ -3148,6 +3152,9 @@
                 add_device_config(DEV_DEBUGCON, optarg);
                 break;
             case QEMU_OPTION_loadvm:
+                if (!loadvm) {
+                    runstate_set(RUN_STATE_RESTORE_VM);
+                }
                 loadvm = optarg;
                 break;
             case QEMU_OPTION_full_screen:
diff -ru --un qemu-7.2.0/target/arm/hvf/hvf.c qemu-utm-7.2.0/target/arm/hvf/hvf.c
--- qemu-7.2.0/target/arm/hvf/hvf.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/target/arm/hvf/hvf.c	2022-12-26 13:45:03
@@ -86,6 +86,8 @@
 #define TMR_CTL_IMASK   (1 << 1)
 #define TMR_CTL_ISTATUS (1 << 2)
 
+static const bool windows_workaround_enabled = true;
+
 static void hvf_wfi(CPUState *cpu);
 
 typedef struct HVFVTimer {
@@ -1282,7 +1284,8 @@
         break;
     case EC_AA64_SMC:
         cpu_synchronize_state(cpu);
-        if (arm_cpu->psci_conduit == QEMU_PSCI_CONDUIT_SMC) {
+        if (windows_workaround_enabled ||
+            arm_cpu->psci_conduit == QEMU_PSCI_CONDUIT_SMC) {
             advance_pc = true;
 
             if (!hvf_handle_psci_call(cpu)) {
diff -ru --un qemu-7.2.0/tcg/aarch64-tcti/README.md qemu-utm-7.2.0/tcg/aarch64-tcti/README.md
--- qemu-7.2.0/tcg/aarch64-tcti/README.md	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/tcg/aarch64-tcti/README.md	2022-12-26 13:45:03
@@ -0,0 +1,1026 @@
+# QEMU Tiny-Code Threaded Interpreter (AArch64)
+
+A TCG backend that chains together JOP/ROP-ish gadgets to massively reduce interpreter overhead vs TCI.
+Platform-dependent; but usable when JIT isn't available; e.g. on platforms that lack WX mappings. The general idea squish the addresses of a gadget sequence into a "queue" and then write each gadget so it ends in a "dequeue-jump".
+
+Execution occurs by jumping into the first gadget, and letting it just play back some linear-overhead native code sequences for a while.
+
+Since TCG-TCI is optimized for sets of 16 GP registers and aarch64 has 30, we could easily keep JIT/QEMU and guest state separate, and since 16\*16 is reasonably small we could actually have a set of reasonable gadgets for each combination of operands.
+
+
+## Register Convention
+
+| Regs    | Use                   |
+| :------ | :-------------------- |
+| x1-x15  | Guest Registers       |
+| x24     | TCTI temporary        |
+| x25     | saved IP during call  |
+| x26     | TCTI temporary        |
+| x27     | TCTI temporary        |
+| x28     | Thread-stream pointer |
+| x30     | Link register         |
+| SP      | Stack Pointer, host   |
+| PC      | Program Counter, host |
+
+In pseudocode:
+
+| Symbol | Meaning                             |
+| :----- | :---------------------------------- |
+| Rd     | stand-in for destination register   |
+| Rn     | stand-in for first source register  |
+| Rm     | stand-in for second source register |
+
+## Gadget Structure
+
+### End of gadget
+
+Each gadget ends by advancing our bytecode pointer, and then executing from thew new location.
+
+```asm
+# Load our next gadget address from our bytecode stream, advancing it, and jump to the next gadget.
+
+ldr x27, [x28], #8\n
+br x27
+```
+
+## Calling into QEMU's C codebase
+
+When calling into C, we lose control over which registers are used. Accordingly, we'll need to save
+registers relevant to TCTI:
+
+```asm
+str x25,      [sp, #-16]!
+stp x14, x15, [sp, #-16]!
+stp x12, x13, [sp, #-16]!
+stp x10, x11, [sp, #-16]!
+stp x8,  x9,  [sp, #-16]!
+stp x6,  x7,  [sp, #-16]!
+stp x4,  x5,  [sp, #-16]!
+stp x2,  x3,  [sp, #-16]!
+stp x0,  x1,  [sp, #-16]!
+stp x28, lr,  [sp, #-16]!
+```
+
+Upon returning to the gadget stream, we'll then restore them.
+
+```asm
+ldp x28, lr, [sp], #16
+ldp x0,  x1, [sp], #16
+ldp x2,  x3, [sp], #16
+ldp x4,  x5, [sp], #16
+ldp x6,  x7, [sp], #16
+ldp x8,  x9, [sp], #16
+ldp x10, x11, [sp], #16
+ldp x12, x13, [sp], #16
+ldp x14, x15, [sp], #16
+ldr x25,      [sp], #16
+```
+
+## TCG Operations
+
+Each operation needs an implementation for every platform; and probably a set of gadgets for each possible set of operands.
+
+At 14 GP registers, that means that
+
+1 operand =\> 16 gadgets
+2 operands =\> 256 gadgets
+3 operands =\> 4096 gadgets
+
+### call
+
+Calls a helper function by address.
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper. This is necessary so the GETPC()
+    # macro works correctly as used in helper functions.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+```
+
+### br
+
+Branches to a given immediate address. Branches are
+
+**IR Format**: `br <ptr address>`  
+**Gadget type:** single
+
+```asm
+# Use our immediate argument as our new bytecode-pointer location.
+ldr x28, [x28]
+```
+
+### setcond_i32
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond32 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Wd, Wn, Wm
+cset Wd, <cond>
+```
+
+| QEMU Cond | AArch64 Cond |
+| :-------- | :----------- |
+| EQ        | EQ           |
+| NE        | NE           |
+| LT        | LT           |
+| GE        | GE           |
+| LE        | LE           |
+| GT        | GT           |
+| LTU       | LO           |
+| GEU       | HS           |
+| LEU       | LS           |
+| GTU       | HI           |
+
+### setcond_i64
+
+Performs a comparison between two 32-bit operands.
+
+**IR Format**: `setcond64 <cond>, Rd, Rn, Rm`  
+**Gadget type:** treated as 10 operations with variants for every `Rd`/`Rn`/`Rm` (40,960)
+
+```asm
+subs Xd, Xn, Xm
+cset Xd, <cond>
+```
+
+Comparison chart is the same as the `_i32` variant.
+
+### brcond_i32
+
+Compares two 32-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Wrz, Wn, Wm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### brcond_i64
+
+Compares two 64-bit numbers, and branches if the comparison is true.
+
+**IR Format**: `brcond Rn, Rm, <cond>`  
+**Gadget type:** treated as 10 operations with variants for every `Rn`/`Rm` (2560)
+
+```asm
+# Perform our comparison and conditional branch.
+subs Xrz, Xn, Xm
+br<cond> taken
+
+    # Consume the branch target, without using it.
+    add x28, x28, #8
+
+    # Perform our end-of-instruction epilogue.
+    <epilogue here>
+
+taken:
+
+    # Update our bytecode pointer to take the label.
+    ldr x28, [x28]
+```
+
+Comparison chart is the same as in `setcond_i32` .
+
+### mov_i32
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Rd, Rn
+```
+
+### mov_i64
+
+Moves a value from a register to another register.
+
+**IR Format**: `mov Rd, Rn`  
+**Gadget type:** gadget per `Rd` + `Rn` combo (256)
+
+```asm
+mov Xd, Xn
+```
+
+### tci_movi_i32
+
+Moves an 32b immediate into a register.
+
+**IR Format**: `mov Rd, #imm32`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr w27, [x28], #4
+mov Wd, w27
+```
+
+### tci_movi_i64
+
+Moves an 64b immediate into a register.
+
+**IR Format**: `mov Rd, #imm64`  
+**Gadget type:** gadget per `Rd` (16)
+
+```asm
+ldr x27, [x28], #4
+mov Xd, x27
+```
+
+### ld8u_i32 / ld8u_i64
+
+Load byte from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrb Xd, [Xn, x27]
+```
+
+### ld8s_i32 / ld8s_i64
+
+Load byte from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsb Xd, [Xn, x27]
+```
+
+### ld16u_i32 / ld16u_i64
+
+Load 16b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrh Wd, [Xn, x27]
+```
+
+### ld16s_i32 / ld16s_i64
+
+Load 16b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsh Xd, [Xn, x27]
+```
+
+### ld32u_i32 / ld32u_i64
+
+Load 32b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Wd, [Xn, x27]
+```
+
+### ld32s_i64
+
+Load 32b from host memory to register; sign extending.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldrsw Xd, [Xn, x27]
+```
+
+### ld_i64
+
+Load 64b from host memory to register.
+
+**IR Format**: `ldr Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+ldr Xd, [Xn, x27]
+```
+
+### st8_i32 / st8_i64
+
+Stores byte from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strb Wd, [Xn, x27]
+```
+
+### st16_i32 / st16_i64
+
+Stores 16b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+strh Wd, [Xn, x27]
+```
+
+### st_i32 / st32_i64
+
+Stores 32b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Wd, [Xn, x27]
+```
+
+### st_i64
+
+Stores 64b from register to host memory.
+
+**IR Format**: `str Rd, Rn, <signed offset>`  
+**Gadget type:** gadget per `Rd` & `Rn` (256)
+
+```asm
+ldrsw x27, [x28], #4
+str Xd, [Xn, x27]
+```
+
+### qemu_ld_i32
+
+Loads 32b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_ld_i64
+
+Loads 64b from _guest_ memory to register.
+
+**IR Format**: `ld Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+### qemu_st_i32
+
+Stores 32b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl
+
+### qemu_st_i64
+
+Stores 64b from a register to _guest_ memory.
+
+**IR Format**: `st Rd, <foreign/guest pointer>, <memory operation>`  
+**Gadget type:** thunk per `Rd` into C impl?
+
+#### Note
+
+See note on `qemu_ld_i32`.
+
+### add_i32
+
+Adds two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Wd, Wn, Wm
+```
+
+### add_i64
+
+Adds two 64-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+add Xd, Xn, Xm
+```
+
+### sub_i32
+
+Subtracts two 32-bit numbers.
+
+**IR Format**: `add Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+Sub Wd, Wn, Wm
+```
+
+### sub_i64
+
+Subtracts two 64-bit numbers.
+
+**IR Format**: `sub Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sub Xd, Xn, Xm
+```
+
+### mul_i32
+
+Multiplies two 32-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Wd, Wn, Wm
+```
+
+### mul_i64
+
+Multiplies two 64-bit numbers.
+
+**IR Format**: `mul Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+mul Xd, Xn, Xm
+```
+
+### div_i32
+
+Divides two 32-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Wd, Wn, Wm
+```
+
+### div_i64
+
+Divides two 64-bit numbers; considering them signed.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv Xd, Xn, Xm
+```
+
+### divu_i32
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Wd, Wn, Wm
+```
+
+### divu_i64
+
+Divides two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `div Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv Xd, Xn, Xm
+```
+
+### rem_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### rem_i64
+
+Computes the division remainder (modulus) of two 64-bit numbers; considering them signed.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+sdiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### remu_i32
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    w27, Wn, Wm
+msub    Wd, w27, Wm, Wn
+```
+
+### remu_i64
+
+Computes the division remainder (modulus) of two 32-bit numbers; considering them unsigned.
+
+**IR Format**: `rem Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+udiv    x27, Xn, Xm
+msub    Xd, x27, Xm, Xn
+```
+
+### not_i32
+
+Logically inverts a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Wd, Wn
+```
+
+### not_i64
+
+Logically inverts a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+mvn Xd, Xn
+```
+
+### neg_i32
+
+Arithmetically inverts (two's compliment) a 32-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Wd, Wn
+```
+
+### neg_i64
+
+Arithmetically inverts (two's compliment) a 64-bit number.
+
+**IR Format**: `not Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+neg Xd, Xn
+```
+
+### and_i32
+
+Logically ANDs two 32-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Wd, Wn, Wm
+```
+
+### and_i64
+
+Logically ANDs two 64-bit numbers.
+
+**IR Format**: `and Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+and Xd, Xn, Xm
+```
+
+### or_i32
+
+Logically ORs two 32-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Wd, Wn, Wm
+```
+
+### or_i64
+
+Logically ORs two 64-bit numbers.
+
+**IR Format**: `or Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+or Xd, Xn, Xm
+```
+
+### xor_i32
+
+Logically XORs two 32-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Wd, Wn, Wm
+```
+
+### xor_i64
+
+Logically XORs two 64-bit numbers.
+
+**IR Format**: `xor Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+eor Xd, Xn, Xm
+```
+
+### shl_i32
+
+Logically shifts a 32-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Wd, Wn, Wm
+```
+
+### shl_i64
+
+Logically shifts a 64-bit number left.
+
+**IR Format**: `shl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsl Xd, Xn, Xm
+```
+
+### shr_i32
+
+Logically shifts a 32-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Wd, Wn, Wm
+```
+
+### shr_i64
+
+Logically shifts a 64-bit number right.
+
+**IR Format**: `shr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+lsr Xd, Xn, Xm
+```
+
+### sar_i32
+
+Arithmetically shifts a 32-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Wd, Wn, Wm
+```
+
+### sar_i64
+
+Arithmetically shifts a 64-bit number right.
+
+**IR Format**: `sar Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+asr Xd, Xn, Xm
+```
+
+### rotl_i32
+
+Rotates a 32-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Wd, Wn, Wm
+```
+
+### rotl_i64
+
+Rotates a 64-bit number left.
+
+**IR Format**: `rotl Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+rol Xd, Xn, Xm
+```
+
+### rotr_i32
+
+Rotates a 32-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Wd, Wn, Wm
+```
+
+### rotr_i64
+
+Rotates a 64-bit number right.
+
+**IR Format**: `rotr Rd, Rn, Rm`  
+**Gadget type:** gadget per `Rd`, `Rn`, `Rm` (4096)
+
+```asm
+ror Xd, Xn, Xm
+```
+
+### deposit_i32
+
+Optional; not currently implementing.
+
+### deposit_i64
+
+Optional; not currently implementing.
+
+### ext8s_i32
+
+Sign extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Wd, Wn
+```
+
+### ext8s_i64
+
+Sign extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtb Xd, Wn
+```
+
+### ext8u_i32
+
+Zero extends the lower 8b of a register into a 32b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext8u_i64
+
+Zero extends the lower 8b of a register into a 64b destination.
+
+**IR Format**: `ext8u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xff
+```
+
+### ext16s_i32
+
+Sign extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16s_i64
+
+Sign extends the lower 16b of a register into a 64b destination.
+
+**IR Format**: `ext16s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxth Xd, Wn
+```
+
+### ext16u_i32
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext16u_i64
+
+Zero extends the lower 16b of a register into a 32b destination.
+
+**IR Format**: `ext16u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Wd, Wn, #0xffff
+```
+
+### ext32s_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext32u_i64
+
+Zero extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### ext_i32_i64
+
+Sign extends the lower 32b of a register into a 64b destination.
+
+**IR Format**: `ext32s Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+sxtw Xd, Wn
+```
+
+### extu_i32_i64
+
+Zero extends the lower 32b of a register into a 32b destination.
+
+**IR Format**: `ext32u Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+and Xd, Xn, #0xffffffff
+```
+
+### bswap16_i32
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap16_i64
+
+Byte-swaps a 16b quantity.
+
+**IR Format**: `bswap16 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     w27, Wn
+lsr     Wd, w27, #16
+```
+
+### bswap32_i32
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap32_i64
+
+Byte-swaps a 32b quantity.
+
+**IR Format**: `bswap32 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Wd, Wn
+```
+
+### bswap64_i64
+
+Byte-swaps a 64b quantity.
+
+**IR Format**: `bswap64 Rd, Rn`  
+**Gadget type:** gadget per `Rd`, `Rn` (256)
+
+```asm
+rev     Xd, Xn
+```
+
+### exit_tb
+
+Exits the translation block. Has no gadget; but instead inserts the address of the translation block epilogue.
+
+
+### mb
+
+Memory barrier.
+
+**IR Format**: `mb <type>`  
+**Gadget type:** gadget per type
+
+```asm
+# !!! TODO
+```
+
+#### Note
+
+We still need to look up out how to map QEMU MB types map to AArch64 ones. This might take nuance.
diff -ru --un qemu-7.2.0/tcg/aarch64-tcti/tcg-target-con-set.h qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target-con-set.h
--- qemu-7.2.0/tcg/aarch64-tcti/tcg-target-con-set.h	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target-con-set.h	2022-12-26 13:45:03
@@ -0,0 +1,21 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * TCI target-specific constraint sets.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * C_On_Im(...) defines a constraint set with <n> outputs and <m> inputs.
+ * Each operand should be a sequence of constraint letters as defined by
+ * tcg-target-con-str.h; the constraint combination is inclusive or.
+ */
+C_O0_I2(r, r)
+C_O0_I3(r, r, r)
+C_O0_I4(r, r, r, r)
+C_O1_I1(r, r)
+C_O1_I2(r, 0, r)
+C_O1_I2(r, r, r)
+C_O1_I4(r, r, r, r, r)
+C_O2_I1(r, r, r)
+C_O2_I2(r, r, r, r)
+C_O2_I4(r, r, r, r, r, r)
diff -ru --un qemu-7.2.0/tcg/aarch64-tcti/tcg-target-con-str.h qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target-con-str.h
--- qemu-7.2.0/tcg/aarch64-tcti/tcg-target-con-str.h	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target-con-str.h	2022-12-26 13:45:03
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: MIT */
+/*
+ * Define TCI target-specific operand constraints.
+ * Copyright (c) 2021 Linaro
+ */
+
+/*
+ * Define constraint letters for register sets:
+ * REGS(letter, register_mask)
+ */
+REGS('r', MAKE_64BIT_MASK(0, TCG_TARGET_NB_REGS))
diff -ru --un qemu-7.2.0/tcg/aarch64-tcti/tcg-target.c.inc qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target.c.inc
--- qemu-7.2.0/tcg/aarch64-tcti/tcg-target.c.inc	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target.c.inc	2022-12-26 13:45:03
@@ -0,0 +1,1347 @@
+/*
+ * Tiny Code Threaded Intepreter for QEMU
+ *
+ * Copyright (c) 2021 Kate Temkin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#define TCTI_GADGET_IMMEDIATE_ARRAY_LEN 64
+
+#include "tcg/tcg-ldst.h"
+
+// Grab our gadget definitions.
+// FIXME: use the system path instead of hardcoding this?
+#include "tcti-gadgets.c.inc"
+
+/* Marker for missing code. */
+#define TODO() \
+    do { \
+        fprintf(stderr, "TODO %s:%u: %s()\n", \
+                __FILE__, __LINE__, __func__); \
+        tcg_abort(); \
+    } while (0)
+
+
+/* Enable TCTI assertions only when debugging TCG (and without NDEBUG defined).
+ * Without assertions, the interpreter runs much faster. */
+#if defined(CONFIG_DEBUG_TCG)
+# define tcti_assert(cond) assert(cond)
+#else
+# define tcti_assert(cond) ((void)0)
+#endif
+
+/* Bitfield n...m (in 32 bit value). */
+#define BITS(n, m) (((0xffffffffU << (31 - n)) >> (31 - n + m)) << m)
+
+/**
+ * Macro that defines a look-up tree for named QEMU_LD gadgets.
+ */ 
+#define LD_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_ld_ub_   ## suffix; break; \
+        case MO_SB:   variable = gadget_qemu_ld_sb_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_ld_leuw_ ## suffix; break; \
+        case MO_LESW: variable = gadget_qemu_ld_lesw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_ld_leul_ ## suffix; break; \
+        case MO_LESL: variable = gadget_qemu_ld_lesl_ ## suffix; break; \
+        case MO_LEUQ: variable = gadget_qemu_ld_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_ld_beuw_ ## suffix; break; \
+        case MO_BESW: variable = gadget_qemu_ld_besw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_ld_beul_ ## suffix; break; \
+        case MO_BESL: variable = gadget_qemu_ld_besl_ ## suffix; break; \
+        case MO_BEUQ: variable = gadget_qemu_ld_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define LD_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            LD_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            LD_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+
+/**
+ * Macro that defines a look-up tree for named QEMU_ST gadgets.
+ */ 
+#define ST_MEMOP_LOOKUP(variable, arg, suffix) \
+    switch (get_memop(arg) & (MO_BSWAP | MO_SSIZE)) { \
+        case MO_UB:   variable = gadget_qemu_st_ub_   ## suffix; break; \
+        case MO_LEUW: variable = gadget_qemu_st_leuw_ ## suffix; break; \
+        case MO_LEUL: variable = gadget_qemu_st_leul_ ## suffix; break; \
+        case MO_LEUQ: variable = gadget_qemu_st_leq_  ## suffix; break; \
+        case MO_BEUW: variable = gadget_qemu_st_beuw_ ## suffix; break; \
+        case MO_BEUL: variable = gadget_qemu_st_beul_ ## suffix; break; \
+        case MO_BEUQ: variable = gadget_qemu_st_beq_  ## suffix; break; \
+        default: \
+            g_assert_not_reached(); \
+    }
+#define ST_MEMOP_HANDLER(variable, arg, suffix, a_bits, s_bits) \
+        if (a_bits >= s_bits) { \
+            ST_MEMOP_LOOKUP(variable, arg, aligned_ ## suffix ); \
+        } else { \
+            ST_MEMOP_LOOKUP(gadget, arg, unaligned_ ## suffix); \
+        }
+
+
+static TCGConstraintSetIndex tcg_target_op_def(TCGOpcode op)
+{
+    switch (op) {
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8s_i32:
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16s_i32:
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld8u_i64:
+    case INDEX_op_ld8s_i64:
+    case INDEX_op_ld16u_i64:
+    case INDEX_op_ld16s_i64:
+    case INDEX_op_ld32u_i64:
+    case INDEX_op_ld32s_i64:
+    case INDEX_op_ld_i64:
+    case INDEX_op_not_i32:
+    case INDEX_op_not_i64:
+    case INDEX_op_neg_i32:
+    case INDEX_op_neg_i64:
+    case INDEX_op_ext8s_i32:
+    case INDEX_op_ext8s_i64:
+    case INDEX_op_ext16s_i32:
+    case INDEX_op_ext16s_i64:
+    case INDEX_op_ext8u_i32:
+    case INDEX_op_ext8u_i64:
+    case INDEX_op_ext16u_i32:
+    case INDEX_op_ext16u_i64:
+    case INDEX_op_ext32s_i64:
+    case INDEX_op_ext32u_i64:
+    case INDEX_op_ext_i32_i64:
+    case INDEX_op_extu_i32_i64:
+    case INDEX_op_bswap16_i32:
+    case INDEX_op_bswap16_i64:
+    case INDEX_op_bswap32_i32:
+    case INDEX_op_bswap32_i64:
+    case INDEX_op_bswap64_i64:
+        return C_O1_I1(r, r);
+
+    case INDEX_op_st8_i32:
+    case INDEX_op_st16_i32:
+    case INDEX_op_st_i32:
+    case INDEX_op_st8_i64:
+    case INDEX_op_st16_i64:
+    case INDEX_op_st32_i64:
+    case INDEX_op_st_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_div_i32:
+    case INDEX_op_div_i64:
+    case INDEX_op_divu_i32:
+    case INDEX_op_divu_i64:
+    case INDEX_op_rem_i32:
+    case INDEX_op_rem_i64:
+    case INDEX_op_remu_i32:
+    case INDEX_op_remu_i64:
+    case INDEX_op_add_i32:
+    case INDEX_op_add_i64:
+    case INDEX_op_sub_i32:
+    case INDEX_op_sub_i64:
+    case INDEX_op_mul_i32:
+    case INDEX_op_mul_i64:
+    case INDEX_op_and_i32:
+    case INDEX_op_and_i64:
+    case INDEX_op_andc_i32:
+    case INDEX_op_andc_i64:
+    case INDEX_op_eqv_i32:
+    case INDEX_op_eqv_i64:
+    case INDEX_op_nand_i32:
+    case INDEX_op_nand_i64:
+    case INDEX_op_nor_i32:
+    case INDEX_op_nor_i64:
+    case INDEX_op_or_i32:
+    case INDEX_op_or_i64:
+    case INDEX_op_orc_i32:
+    case INDEX_op_orc_i64:
+    case INDEX_op_xor_i32:
+    case INDEX_op_xor_i64:
+    case INDEX_op_shl_i32:
+    case INDEX_op_shl_i64:
+    case INDEX_op_shr_i32:
+    case INDEX_op_shr_i64:
+    case INDEX_op_sar_i32:
+    case INDEX_op_sar_i64:
+    case INDEX_op_rotl_i32:
+    case INDEX_op_rotl_i64:
+    case INDEX_op_rotr_i32:
+    case INDEX_op_rotr_i64:
+    case INDEX_op_setcond_i32:
+    case INDEX_op_setcond_i64:
+        return C_O1_I2(r, r, r);
+
+    case INDEX_op_brcond_i32:
+    case INDEX_op_brcond_i64:
+        return C_O0_I2(r, r);
+
+    case INDEX_op_qemu_ld_i32:
+    case INDEX_op_qemu_ld_i64:
+        return C_O1_I2(r, r, r);
+    case INDEX_op_qemu_st_i32:
+    case INDEX_op_qemu_st_i64:
+        return C_O0_I3(r, r, r);
+
+    default:
+        g_assert_not_reached();
+    }
+}
+
+static const int tcg_target_reg_alloc_order[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    /*
+    TCG_REG_R14,  // AREG0
+    TCG_REG_R15,  // SP
+    */
+};
+
+#if MAX_OPC_PARAM_IARGS != 7
+# error Fix needed, number of supported input arguments changed!
+#endif
+
+static const int tcg_target_call_iarg_regs[] = {
+    TCG_REG_R0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+};
+
+static const int tcg_target_call_oarg_regs[] = {
+    TCG_REG_R0,
+};
+
+#ifdef CONFIG_DEBUG_TCG
+static const char *const tcg_target_reg_names[TCG_TARGET_NB_REGS] = {
+    "r00",
+    "r01",
+    "r02",
+    "r03",
+    "r04",
+    "r05",
+    "r06",
+    "r07",
+    "r08",
+    "r09",
+    "r10",
+    "r11",
+    "r12",
+    "r13",
+    "r14",
+    "r15",
+};
+#endif
+
+static bool patch_reloc(tcg_insn_unit *code_ptr, int type,
+                        intptr_t value, intptr_t addend)
+{
+    /* tcg_out_reloc always uses the same type, addend. */
+    tcg_debug_assert(type == sizeof(tcg_target_long));
+    tcg_debug_assert(addend == 0);
+    tcg_debug_assert(value != 0);
+    if (TCG_TARGET_REG_BITS == 32) {
+        tcg_patch32(code_ptr, value);
+    } else {
+        tcg_patch64(code_ptr, value);
+    }
+    return true;
+}
+
+#if defined(CONFIG_DEBUG_TCG_INTERPRETER)
+/* Show current bytecode. Used by tcg interpreter. */
+void tci_disas(uint8_t opc)
+{
+    const TCGOpDef *def = &tcg_op_defs[opc];
+    fprintf(stderr, "TCG %s %u, %u, %u\n",
+            def->name, def->nb_oargs, def->nb_iargs, def->nb_cargs);
+}
+#endif
+
+/* Write value (native size). */
+static void tcg_out_immediate(TCGContext *s, tcg_target_ulong v)
+{
+    if (TCG_TARGET_REG_BITS == 32) {
+        //tcg_out32(s, v);
+        tcg_out64(s, v);
+    } else {
+        tcg_out64(s, v);
+    }
+}
+
+void tb_target_set_jmp_target(uintptr_t tc_ptr, uintptr_t jmp_rx, uintptr_t jmp_rw, uintptr_t addr)
+{
+    /* Get a pointer to our immediate, which exists after a single pointer. */
+    uintptr_t immediate_addr = jmp_rw;
+
+    /* Patch it to be match our target address. */
+    qatomic_set((uint64_t *)immediate_addr, addr);
+}
+
+
+/**
+ * TCTI Thunk Helpers
+ */
+
+#ifdef CONFIG_SOFTMMU
+
+// TODO: relocate these prototypes?
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr);
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr);
+
+tcg_target_ulong helper_ret_ldub_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr)
+{
+    return (int8_t)helper_ret_ldub_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_lduw_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_le_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_le_ldul_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_le_ldul_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_lduw_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr)
+{
+    return (int16_t)helper_be_lduw_mmu(env, addr, oi, retaddr);
+}
+
+tcg_target_ulong helper_be_ldul_mmu_signed(CPUArchState *env, target_ulong addr, MemOpIdx oi, uintptr_t retaddr)
+{
+    return (int32_t)helper_be_ldul_mmu(env, addr, oi, retaddr);
+}
+
+#else
+#error TCTI currently only supports use of the soft MMU.
+#endif
+
+
+/**
+ * TCTI Emmiter Helpers
+ */
+
+
+/* Write gadget pointer. */
+static void tcg_out_nullary_gadget(TCGContext *s, void *gadget)
+{
+    tcg_out_immediate(s, (tcg_target_ulong)gadget);
+}
+
+/* Write gadget pointer, plus 64b immediate. */
+static void tcg_out_imm64_gadget(TCGContext *s, void *gadget, tcg_target_ulong immediate)
+{
+    tcg_out_nullary_gadget(s, gadget);
+    tcg_out64(s, immediate);
+}
+
+
+/* Write gadget pointer (one register). */
+static void tcg_out_unary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS], unsigned reg0)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0]);
+}
+
+
+/* Write gadget pointer (two registers). */
+static void tcg_out_binary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1]);
+}
+
+
+/* Write gadget pointer (three registers). */
+static void tcg_out_ternary_gadget(TCGContext *s, void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], unsigned reg0, unsigned reg1, unsigned reg2)
+{
+    tcg_out_nullary_gadget(s, gadget_base[reg0][reg1][reg2]);
+}
+
+
+/**
+ * Version of our LDST generator that defers to more optimized gadgets selectively.
+ */
+static void tcg_out_ldst_gadget_inner(TCGContext *s, 
+    void *gadget_base[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS], 
+    void *gadget_pos_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_shifted_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    void *gadget_neg_imm[TCG_TARGET_NB_REGS][TCG_TARGET_NB_REGS][TCTI_GADGET_IMMEDIATE_ARRAY_LEN], 
+    unsigned reg0, unsigned reg1, uint32_t offset)
+{
+    int64_t extended_offset = (int32_t)offset;
+    bool is_negative = (extended_offset < 0);
+
+    // Optimal case: we have a gadget that handles our specific offset, so we don't need to encode
+    // an immediate. This saves us a bunch of speed. :)
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        uint64_t shifted_offset = (extended_offset >> 3);
+        bool aligned_to_8B = ((extended_offset & 0b111) == 0);
+
+        bool have_optimized_gadget = (extended_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+        bool have_shifted_gadget   = (shifted_offset  < TCTI_GADGET_IMMEDIATE_ARRAY_LEN);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (have_optimized_gadget) {
+            tcg_out_nullary_gadget(s, gadget_pos_imm[reg0][reg1][extended_offset]);
+            return;
+        } 
+
+        // Special case: it's frequent to have low-numbered positive offsets that are aligned
+        // to 16B boundaries
+        else if(aligned_to_8B && have_shifted_gadget) {
+            tcg_out_nullary_gadget(s, gadget_shifted_imm[reg0][reg1][shifted_offset]);
+            return;
+        }
+    } 
+    else {
+        uint64_t negated_offset = -(extended_offset);
+
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (negated_offset < TCTI_GADGET_IMMEDIATE_ARRAY_LEN) {
+            tcg_out_nullary_gadget(s, gadget_neg_imm[reg0][reg1][negated_offset]);
+            return;
+        }
+    }
+
+    // Less optimal case: we don't have a gadget specifically for this. Emit the general case immediate.
+    tcg_out_binary_gadget(s, gadget_base, reg0, reg1);
+    tcg_out64(s, extended_offset); //tcg_out32(s, offset);
+}
+
+/* Shorthand for the above, that prevents us from having to specify the name three times. */
+#define tcg_out_ldst_gadget(s, name, a, b, c) \
+    tcg_out_ldst_gadget_inner(s, name, \
+        name ## _imm,  \
+        name ## _sh8_imm,  \
+        name ## _neg_imm, \
+    a, b, c)
+
+
+
+/* Write label. */
+static void tcti_out_label(TCGContext *s, TCGLabel *label)
+{
+    if (label->has_value) {
+        tcg_out64(s, label->u.value);
+        tcg_debug_assert(label->u.value);
+    } else {
+        tcg_out_reloc(s, s->code_ptr, sizeof(tcg_target_ulong), label, 0);
+        s->code_ptr += sizeof(tcg_target_ulong);
+    }
+}
+
+/**
+ * Generate a register-to-register MOV.
+ */
+static bool tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
+{
+    tcg_debug_assert(ret != arg);
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_binary_gadget(s, gadget_mov_i32, ret, arg);
+    } else {
+        tcg_out_binary_gadget(s, gadget_mov_i64, ret, arg);
+    }
+
+
+    return true;
+}
+
+
+static void tcg_out_movi_i32(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    bool is_negative = (arg < 0);
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i32[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i32[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // Emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i32, t0);
+    tcg_out64(s, arg); // TODO: make 32b?
+}
+
+
+static void tcg_out_movi_i64(TCGContext *s, TCGReg t0, tcg_target_long arg)
+{
+    uint8_t is_negative = arg < 0;
+
+    // We handle positive and negative gadgets separately, in order to allow for asymmetrical
+    // collections of pre-made gadgets.
+    if (!is_negative) 
+    {
+        // More optimal case: we have a gadget that directly encodes the argument.
+        if (arg < ARRAY_SIZE(gadget_movi_imm_i64[t0])) {
+            tcg_out_nullary_gadget(s, gadget_movi_imm_i64[t0][arg]);
+            return;
+        }
+    } 
+    else {
+
+    }
+
+    // TODO: optimize the negative case, too?
+
+    // Less optimal case: emit the mov and its immediate.
+    tcg_out_unary_gadget(s, gadget_movi_i64, t0);
+    tcg_out64(s, arg);
+}
+
+
+/**
+ * Generate an immediate-to-register MOV.
+ */
+static void tcg_out_movi(TCGContext *s, TCGType type, TCGReg t0, tcg_target_long arg)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_movi_i32(s, t0, arg);
+    } else {
+        tcg_out_movi_i64(s, t0, arg);
+    }
+}
+
+/**
+ * Generate a CALL.
+ */
+static inline void tcg_out_call(TCGContext *s, const tcg_insn_unit *arg)
+{
+    tcg_out_nullary_gadget(s, gadget_call);
+    tcg_out64(s, (uintptr_t)arg);
+}
+
+/**
+ * Generates LD instructions.
+ */
+static void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1,
+                       intptr_t arg2)
+{
+
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_ld32u, ret, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_ld_i64, ret, arg1, arg2); 
+    }
+}
+
+
+/**
+ * Generate every other operation.
+ */
+//static void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *const_args)
+{
+    switch (opc) {
+
+    // Exit translation, and return back to QEMU.
+    case INDEX_op_exit_tb:
+        // Emit a simple gadget with a known return code.
+        tcg_out_imm64_gadget(s, gadget_exit_tb, args[0]);
+        break;
+
+    // Jump to a translation block.
+    case INDEX_op_goto_tb:
+
+        // If we're using a direct jump, we'll emit a "relocation" that can be usd
+        // to patch our gadget stream with the target address, later.
+        if (s->tb_jmp_insn_offset) {
+            // Emit our gadget.
+            tcg_out_nullary_gadget(s, gadget_br);
+
+            // Place our current instruction into our "relocation table", so it can
+            // be patched once we know where the branch will target...
+            s->tb_jmp_insn_offset[args[0]] = tcg_current_code_size(s);
+
+            // ... and emit our relocation.
+            tcg_out64(s, args[0]);
+
+
+        } else {
+            /* Indirect jump method. */
+            TODO();
+        }
+        set_jmp_reset_offset(s, args[0]);
+        break;
+
+    // Simple branch.
+    case INDEX_op_br:
+        tcg_out_nullary_gadget(s, gadget_br);
+        tcti_out_label(s, arg_label(args[0]));
+        break;
+
+
+    // Set condition flag.
+    // a0 = Rd, a1 = Rn, a2 = Rm
+    case INDEX_op_setcond_i32:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    case INDEX_op_setcond_i64:
+    {
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[3]) {
+            case TCG_COND_EQ:  gadget = gadget_setcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_setcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_setcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_setcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_setcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_setcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_setcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_setcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_setcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_setcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        tcg_out_ternary_gadget(s, gadget, args[0], args[1], args[2]);
+        break;
+    }
+
+    /**
+     * Load instructions.
+     */
+
+    case INDEX_op_ld8u_i32:
+    case INDEX_op_ld8u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld8s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld8s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16u_i32:
+    case INDEX_op_ld16u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i32:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld16s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld16s_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i32:
+    case INDEX_op_ld32u_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32u, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_ld_i64:
+        tcg_out_ldst_gadget(s, gadget_ld_i64, args[0], args[1], args[2]); 
+        break;
+    
+    case INDEX_op_ld32s_i64:
+        tcg_out_ldst_gadget(s, gadget_ld32s_i64, args[0], args[1], args[2]); 
+        break;
+
+
+    /**
+     * Store instructions.
+     */
+    case INDEX_op_st8_i32:
+    case INDEX_op_st8_i64:
+        tcg_out_ldst_gadget(s, gadget_st8, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st16_i32:
+    case INDEX_op_st16_i64:
+        tcg_out_ldst_gadget(s, gadget_st16, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i32:
+    case INDEX_op_st32_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_st_i64:
+        tcg_out_ldst_gadget(s, gadget_st_i64, args[0], args[1], args[2]); 
+        break;
+
+    /**
+     * Arithmetic instructions.
+     */
+
+    case INDEX_op_add_i32: 
+        tcg_out_ternary_gadget(s, gadget_add_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i32:
+        tcg_out_ternary_gadget(s, gadget_sub_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i32:
+        tcg_out_ternary_gadget(s, gadget_mul_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i32:
+        tcg_out_ternary_gadget(s, gadget_and_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i32:     /* Optional (TCG_TARGET_HAS_andc_i32). */
+        tcg_out_ternary_gadget(s, gadget_andc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i32:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_or_i32:
+        tcg_out_ternary_gadget(s, gadget_or_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i32:
+        tcg_out_ternary_gadget(s, gadget_xor_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i32:
+        tcg_out_ternary_gadget(s, gadget_shl_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i32:
+        tcg_out_ternary_gadget(s, gadget_shr_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i32:
+        tcg_out_ternary_gadget(s, gadget_sar_i32, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotr_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i32, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotl_i32:     /* Optional (TCG_TARGET_HAS_rot_i32). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i32, args[0], args[1], args[2]); 
+
+    case INDEX_op_add_i64:
+        tcg_out_ternary_gadget(s, gadget_add_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sub_i64:
+        tcg_out_ternary_gadget(s, gadget_sub_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_mul_i64:
+        tcg_out_ternary_gadget(s, gadget_mul_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_and_i64:
+        tcg_out_ternary_gadget(s, gadget_and_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_andc_i64:     /* Optional (TCG_TARGET_HAS_andc_i64). */
+        tcg_out_ternary_gadget(s, gadget_andc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_orc_i64:      /* Optional (TCG_TARGET_HAS_orc_i64). */
+        tcg_out_ternary_gadget(s, gadget_orc_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_eqv_i64:      /* Optional (TCG_TARGET_HAS_eqv_i64). */
+        tcg_out_ternary_gadget(s, gadget_eqv_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_nand_i64:     /* Optional (TCG_TARGET_HAS_nand_i64). */
+    //case INDEX_op_nor_i64:      /* Optional (TCG_TARGET_HAS_nor_i64). */
+
+    case INDEX_op_or_i64:
+        tcg_out_ternary_gadget(s, gadget_or_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_xor_i64:
+        tcg_out_ternary_gadget(s, gadget_xor_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shl_i64:
+        tcg_out_ternary_gadget(s, gadget_shl_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_shr_i64:
+        tcg_out_ternary_gadget(s, gadget_shr_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_sar_i64:
+        tcg_out_ternary_gadget(s, gadget_sar_i64, args[0], args[1], args[2]); 
+        break;
+
+    //case INDEX_op_rotl_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotl_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    //case INDEX_op_rotr_i64:     /* Optional (TCG_TARGET_HAS_rot_i64). */
+    //    tcg_out_ternary_gadget(s, gadget_rotr_i64, args[0], args[1], args[2]); 
+    //    break;
+
+    case INDEX_op_div_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_div_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_divu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i64:      /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_rem_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i64:     /* Optional (TCG_TARGET_HAS_div_i64). */
+        tcg_out_ternary_gadget(s, gadget_remu_i64, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i64:
+    {
+        static uint8_t last_brcond_i64 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i64_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i64_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i64_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i64_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i64_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i64_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i64_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i64_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i64_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i64_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i64, args[0], args[1]);
+        last_brcond_i64 = (last_brcond_i64 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+        break;
+    }
+
+
+    case INDEX_op_bswap16_i32:  /* Optional (TCG_TARGET_HAS_bswap16_i32). */
+    case INDEX_op_bswap16_i64:  /* Optional (TCG_TARGET_HAS_bswap16_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap16, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap32_i32:  /* Optional (TCG_TARGET_HAS_bswap32_i32). */
+    case INDEX_op_bswap32_i64:  /* Optional (TCG_TARGET_HAS_bswap32_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap32, args[0], args[1]);
+        break;
+
+    case INDEX_op_bswap64_i64:  /* Optional (TCG_TARGET_HAS_bswap64_i64). */
+        tcg_out_binary_gadget(s, gadget_bswap64, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i64:      /* Optional (TCG_TARGET_HAS_not_i64). */
+        tcg_out_binary_gadget(s, gadget_not_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i64:      /* Optional (TCG_TARGET_HAS_neg_i64). */
+        tcg_out_binary_gadget(s, gadget_neg_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i64:    /* Optional (TCG_TARGET_HAS_ext8s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8u_i32:    /* Optional (TCG_TARGET_HAS_ext8u_i32). */
+    case INDEX_op_ext8u_i64:    /* Optional (TCG_TARGET_HAS_ext8u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext8u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i64:   /* Optional (TCG_TARGET_HAS_ext16s_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16u_i32:   /* Optional (TCG_TARGET_HAS_ext16u_i32). */
+    case INDEX_op_ext16u_i64:   /* Optional (TCG_TARGET_HAS_ext16u_i64). */
+        tcg_out_binary_gadget(s, gadget_ext16u, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32s_i64:   /* Optional (TCG_TARGET_HAS_ext32s_i64). */
+    case INDEX_op_ext_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32s_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext32u_i64:   /* Optional (TCG_TARGET_HAS_ext32u_i64). */
+    case INDEX_op_extu_i32_i64:
+        tcg_out_binary_gadget(s, gadget_ext32u_i64, args[0], args[1]);
+        break;
+
+    case INDEX_op_neg_i32:      /* Optional (TCG_TARGET_HAS_neg_i32). */
+        tcg_out_binary_gadget(s, gadget_neg_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_not_i32:      /* Optional (TCG_TARGET_HAS_not_i32). */
+        tcg_out_binary_gadget(s, gadget_not_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext8s_i32:    /* Optional (TCG_TARGET_HAS_ext8s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext8s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_ext16s_i32:   /* Optional (TCG_TARGET_HAS_ext16s_i32). */
+        tcg_out_binary_gadget(s, gadget_ext16s_i32, args[0], args[1]);
+        break;
+
+    case INDEX_op_div_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_div_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_divu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_divu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_rem_i32:      /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_rem_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_remu_i32:     /* Optional (TCG_TARGET_HAS_div_i32). */
+        tcg_out_ternary_gadget(s, gadget_remu_i32, args[0], args[1], args[2]); 
+        break;
+
+    case INDEX_op_brcond_i32:
+    {
+        static uint8_t last_brcond_i32 = 0;
+        void *gadget;
+
+        // We have to emit a different gadget per condition; we'll select which.
+        switch(args[2]) {
+            case TCG_COND_EQ:  gadget = gadget_brcond_i32_eq; break;
+            case TCG_COND_NE:  gadget = gadget_brcond_i32_ne; break;
+            case TCG_COND_LT:  gadget = gadget_brcond_i32_lt; break;
+            case TCG_COND_GE:  gadget = gadget_brcond_i32_ge; break;
+            case TCG_COND_LE:  gadget = gadget_brcond_i32_le; break;
+            case TCG_COND_GT:  gadget = gadget_brcond_i32_gt; break;
+            case TCG_COND_LTU: gadget = gadget_brcond_i32_lo; break;
+            case TCG_COND_GEU: gadget = gadget_brcond_i32_hs; break;
+            case TCG_COND_LEU: gadget = gadget_brcond_i32_ls; break;
+            case TCG_COND_GTU: gadget = gadget_brcond_i32_hi; break;
+            default:
+                g_assert_not_reached();
+        }
+
+        // We'll select the which branch to used based on a cycling counter.
+        // This means we'll pick one of 16 identical brconds. Spreading this out
+        // helps the processor's branch prediction be less "squished", as not every
+        // branch is going throuh the same instruction.
+        tcg_out_ternary_gadget(s, gadget, last_brcond_i32, args[0], args[1]);
+        last_brcond_i32 = (last_brcond_i32 + 1) % TCG_TARGET_NB_REGS;
+
+        // Branch target immediate.
+        tcti_out_label(s, arg_label(args[3]));
+
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        break;
+    }
+
+    case INDEX_op_qemu_ld_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_ld_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_ld_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_ld_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  LD_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  LD_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: LD_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   LD_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+            // Args:
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // TODO: fix encoding to be 4b
+        }
+
+        break;
+    }
+
+    case INDEX_op_qemu_st_i32:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+            case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i32, a_bits, s_bits); break;
+            case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i32, a_bits, s_bits); break;
+            case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i32, a_bits, s_bits); break;
+            default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i32); break;
+        }
+
+        // Args:
+        // - our gadget encodes the target and address registers
+        // - an immediate32 encodes our operation index 
+        tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        tcg_out64(s, args[2]); // FIXME: double encoded
+        break;
+    }
+
+    case INDEX_op_qemu_st_i64:
+    {
+        MemOp opc = get_memop(args[2]);
+        unsigned a_bits = get_alignment_bits(opc);
+        unsigned s_bits = opc & MO_SIZE;
+
+        void *gadget;
+
+        // Special optimization case: if we have an operation/target of 0x3A, 
+        // this is a common case. Delegate to our special-case handler.
+        if (args[2] == 0x3a) {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+
+                case -64: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off64_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off64_i64;
+                    break;
+                case -96: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off96_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off96_i64;
+                    break;
+                case -128: 
+                    gadget = (a_bits >= s_bits) ? 
+                        gadget_qemu_st_leq_aligned_mode3a_off128_i64 :
+                        gadget_qemu_st_leq_unaligned_mode3a_off128_i64;
+                    break;
+
+                default: 
+                    gadget = gadget_qemu_st_leq_slowpath_mode3a_off0_i64;
+                    break;
+            }
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+        } 
+        // Otherwise, handle the generic case.
+        else {
+            switch(TLB_MASK_TABLE_OFS(get_mmuidx(args[2]))) {
+                case -64:  ST_MEMOP_HANDLER(gadget, args[2],  off64_i64, a_bits, s_bits); break;
+                case -96:  ST_MEMOP_HANDLER(gadget, args[2],  off96_i64, a_bits, s_bits); break;
+                case -128: ST_MEMOP_HANDLER(gadget, args[2], off128_i64, a_bits, s_bits); break;
+                default:   ST_MEMOP_LOOKUP(gadget, args[2], slowpath_off0_i64); break;
+            }
+
+            // Args:
+            // - our gadget encodes the target and address registers
+            // - an immediate32 encodes our operation index 
+            tcg_out_binary_gadget(s, gadget, args[0], args[1]);
+            tcg_out64(s, args[2]); // FIXME: double encoded
+        }
+
+        break;
+    }
+
+    // Memory barriers.
+    case INDEX_op_mb:
+    {
+        static void* sync[] = {
+            [0 ... TCG_MO_ALL]            = gadget_mb_all,
+            [TCG_MO_ST_ST]                = gadget_mb_st,
+            [TCG_MO_LD_LD]                = gadget_mb_ld,
+            [TCG_MO_LD_ST]                = gadget_mb_ld,
+            [TCG_MO_LD_ST | TCG_MO_LD_LD] = gadget_mb_ld,
+        };
+        tcg_out_nullary_gadget(s, sync[args[0] & TCG_MO_ALL]);
+
+        break;
+    }
+
+    case INDEX_op_mov_i32:  /* Always emitted via tcg_out_mov.  */
+    case INDEX_op_mov_i64:
+    case INDEX_op_call:     /* Always emitted via tcg_out_call.  */
+    default:
+        tcg_abort();
+    }
+}
+
+/**
+ * Generate immediate stores.
+ */
+static void tcg_out_st(TCGContext *s, TCGType type, TCGReg arg, TCGReg arg1,
+                       intptr_t arg2)
+{
+    if (type == TCG_TYPE_I32) {
+        tcg_out_ldst_gadget(s, gadget_st_i32, arg, arg1, arg2); 
+    } else {
+        tcg_out_ldst_gadget(s, gadget_st_i64, arg, arg1, arg2); 
+    }
+}
+
+static inline bool tcg_out_sti(TCGContext *s, TCGType type, TCGArg val,
+                               TCGReg base, intptr_t ofs)
+{
+    return false;
+}
+
+/* Test if a constant matches the constraint. */
+static bool tcg_target_const_match(int64_t val, TCGType type, int ct)
+{
+    return ct & TCG_CT_CONST;
+}
+
+static void tcg_target_init(TCGContext *s)
+{
+    /* The current code uses uint8_t for tcg operations. */
+    tcg_debug_assert(tcg_op_defs_max <= UINT8_MAX);
+
+    /* Registers available for 32 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I32] = BIT(TCG_TARGET_NB_REGS) - 1;
+    /* Registers available for 64 bit operations. */
+    tcg_target_available_regs[TCG_TYPE_I64] = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    /* TODO: Which registers should be set here? */
+    tcg_target_call_clobber_regs = BIT(TCG_TARGET_NB_REGS) - 1;
+
+    s->reserved_regs = 0;
+    tcg_regset_set_reg(s->reserved_regs, TCG_REG_CALL_STACK);
+
+    /* We use negative offsets from "sp" so that we can distinguish
+       stores that might pretend to be call arguments.  */
+    tcg_set_frame(s, TCG_REG_CALL_STACK, -CPU_TEMP_BUF_NLONGS * sizeof(long), CPU_TEMP_BUF_NLONGS * sizeof(long));
+}
+
+/* Generate global QEMU prologue and epilogue code. */
+static inline void tcg_target_qemu_prologue(TCGContext *s)
+{
+    // No prologue; as we're interpreted.
+}
+
+
+/**
+ * TCTI 'interpreter' bootstrap.
+ */
+
+// Store the current return address during helper calls.
+__thread uintptr_t tcti_call_return_address;
+
+/* Dispatch the bytecode stream contained in our translation buffer. */
+uintptr_t QEMU_DISABLE_CFI tcg_qemu_tb_exec(CPUArchState *env, const void *v_tb_ptr)
+{
+    // Create our per-CPU temporary storage.
+    long tcg_temps[CPU_TEMP_BUF_NLONGS];
+
+    uint64_t return_value = 0;
+    uintptr_t sp_value    = (uintptr_t)(tcg_temps + CPU_TEMP_BUF_NLONGS);
+    uintptr_t pc_mirror   = (uintptr_t)&tcti_call_return_address;
+
+    // Ensure our target configuration hasn't changed.
+    tcti_assert(TCG_AREG0 == TCG_REG_R14);
+    tcti_assert(TCG_REG_CALL_STACK == TCG_REG_R15);
+
+    asm(
+        // Our threaded-dispatch prologue needs to set up things for our machine to run.
+        // This means:
+        //   - Set up TCG_AREG0 (R14) to point to our architectural state.
+        //   - Set up TCG_REG_CALL_STACK (R15) to point to our temporary buffer.
+        //   - Point x28 (our bytecode "instruction pointer") to the relevant stream address.
+        "ldr x14, %[areg0]\n"
+        "ldr x15, %[sp_value]\n"
+        "ldr x25, %[pc_mirror]\n"
+        "ldr x28, %[start_tb_ptr]\n"
+
+        // To start our code, we'll -call- the gadget at the first bytecode pointer.
+        // Note that we call/branch-with-link, here; so our TB_EXIT gadget can RET in order
+        // to return to this point when things are complete.
+        "ldr x27, [x28], #8\n"
+        "blr x27\n"
+
+        // Finally, we'll copy out our final return value.
+        "str x0, %[return_value]\n"
+
+        : [return_value] "=m" (return_value)
+
+        : [areg0]        "m"  (env), 
+          [sp_value]     "m"  (sp_value), 
+          [start_tb_ptr] "m"  (v_tb_ptr),
+          [pc_mirror]    "m"  (pc_mirror)
+
+        // We touch _every_ one of the lower registers, as we use these to execute directly.
+        : "x0", "x1",  "x2",  "x3",  "x4",  "x5",  "x6",  "x7",
+          "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15",
+
+        // We also use x26/x27 for temporary values, and x28 as our bytecode poitner.
+        "x25", "x26", "x27", "x28", "cc", "memory"
+    );
+
+    return return_value;
+}
+
+
+/**
+ *  Disassembly output support.
+ */
+#include <dlfcn.h>
+
+
+/* Disassemble TCI bytecode. */
+int print_insn_tcti(bfd_vma addr, disassemble_info *info)
+{
+    Dl_info symbol_info = {};
+    char symbol_name[48] ;
+
+    int status;
+    uint64_t block;
+
+    // Read the relevant pointer.
+    status = info->read_memory_func(addr, (void *)&block, sizeof(block), info);
+    if (status != 0) {
+        info->memory_error_func(status, addr, info);
+        return -1;
+    }
+
+    // Most of our disassembly stream will be gadgets. Try to get their names, for nice output.
+    dladdr((void *)block, &symbol_info);
+
+    if(symbol_info.dli_sname != 0) {
+        strlcpy(symbol_name, symbol_info.dli_sname, 47);
+        info->fprintf_func(info->stream, "%s", symbol_name);
+    } else {
+        info->fprintf_func(info->stream, "%016llx", block);
+    }
+
+    return sizeof(block);
+}
+
+
diff -ru --un qemu-7.2.0/tcg/aarch64-tcti/tcg-target.h qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target.h
--- qemu-7.2.0/tcg/aarch64-tcti/tcg-target.h	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/tcg/aarch64-tcti/tcg-target.h	2022-12-26 13:45:03
@@ -0,0 +1,216 @@
+/*
+ * Tiny Code Generator for QEMU
+ *
+ * Copyright (c) 2009, 2011 Stefan Weil
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+/*
+ * This code implements a TCG which does not generate machine code for some
+ * real target machine but which generates virtual machine code for an
+ * interpreter. Interpreted pseudo code is slow, but it works on any host.
+ *
+ * Some remarks might help in understanding the code:
+ *
+ * "target" or "TCG target" is the machine which runs the generated code.
+ * This is different to the usual meaning in QEMU where "target" is the
+ * emulated machine. So normally QEMU host is identical to TCG target.
+ * Here the TCG target is a virtual machine, but this virtual machine must
+ * use the same word size like the real machine.
+ * Therefore, we need both 32 and 64 bit virtual machines (interpreter).
+ */
+
+#ifndef TCG_TARGET_H
+#define TCG_TARGET_H
+
+#if UINTPTR_MAX == UINT32_MAX
+# error We only support AArch64 running in 64B mode.
+#elif UINTPTR_MAX == UINT64_MAX
+# define TCG_TARGET_REG_BITS 64
+#else
+# error Unknown pointer size for tcti target
+#endif
+
+#define TCG_TARGET_INSN_UNIT_SIZE        1
+#define TCG_TARGET_TLB_DISPLACEMENT_BITS 32
+#define MAX_CODE_GEN_BUFFER_SIZE  ((size_t)-1)
+
+// We're an interpreted target; even if we're JIT-compiling to our interpreter's
+// weird psuedo-native bytecode. We'll indicate that we're intepreted.
+#define TCG_TARGET_INTERPRETER 1
+
+//
+// Supported optional instructions.
+//
+
+// Divs.
+#define TCG_TARGET_HAS_div_i32          1
+#define TCG_TARGET_HAS_rem_i32          1
+#define TCG_TARGET_HAS_div_i64          1
+#define TCG_TARGET_HAS_rem_i64          1
+
+// Extends.
+#define TCG_TARGET_HAS_ext8s_i32        1
+#define TCG_TARGET_HAS_ext16s_i32       1
+#define TCG_TARGET_HAS_ext8u_i32        1
+#define TCG_TARGET_HAS_ext16u_i32       1
+#define TCG_TARGET_HAS_ext8s_i64        1
+#define TCG_TARGET_HAS_ext16s_i64       1
+#define TCG_TARGET_HAS_ext32s_i64       1
+#define TCG_TARGET_HAS_ext8u_i64        1
+#define TCG_TARGET_HAS_ext16u_i64       1
+#define TCG_TARGET_HAS_ext32u_i64       1
+
+// Logicals.
+#define TCG_TARGET_HAS_neg_i32          1
+#define TCG_TARGET_HAS_not_i32          1
+#define TCG_TARGET_HAS_neg_i64          1
+#define TCG_TARGET_HAS_not_i64          1
+
+#define TCG_TARGET_HAS_andc_i32         1
+#define TCG_TARGET_HAS_orc_i32          1
+#define TCG_TARGET_HAS_eqv_i32          1
+#define TCG_TARGET_HAS_andc_i64         1
+#define TCG_TARGET_HAS_eqv_i64          1
+#define TCG_TARGET_HAS_orc_i64          1
+
+// We don't curretly support rotates, since AArch64 lacks ROL.
+// We'll fix this later.
+#define TCG_TARGET_HAS_rot_i32          0
+#define TCG_TARGET_HAS_rot_i64          0
+
+// Swaps.
+#define TCG_TARGET_HAS_bswap16_i32      1
+#define TCG_TARGET_HAS_bswap32_i32      1
+#define TCG_TARGET_HAS_bswap16_i64      1
+#define TCG_TARGET_HAS_bswap32_i64      1
+#define TCG_TARGET_HAS_bswap64_i64      1
+#define TCG_TARGET_HAS_MEMORY_BSWAP     1
+
+// Specify we'll handle direct jumps.
+#define TCG_TARGET_HAS_direct_jump      1
+
+//
+// Potential TODOs.
+//
+
+// TODO: implement DEPOSIT as BFI.
+#define TCG_TARGET_HAS_deposit_i32      0
+#define TCG_TARGET_HAS_deposit_i64      0
+
+// TODO: implement EXTRACT as BFX.
+#define TCG_TARGET_HAS_extract_i32      0
+#define TCG_TARGET_HAS_sextract_i32     0
+#define TCG_TARGET_HAS_extract_i64      0
+#define TCG_TARGET_HAS_sextract_i64     0
+
+// TODO: it might be worth writing a gadget for this
+#define TCG_TARGET_HAS_movcond_i32      0
+#define TCG_TARGET_HAS_movcond_i64      0
+
+//
+// Unsupported instructions.
+//
+
+// ARMv8 doesn't have instructions for NAND/NOR.
+#define TCG_TARGET_HAS_nand_i32         0
+#define TCG_TARGET_HAS_nor_i32          0
+#define TCG_TARGET_HAS_nor_i64          0
+#define TCG_TARGET_HAS_nand_i64         0
+
+// aarch64's CLZ is implemented without a condition, so it
+#define TCG_TARGET_HAS_clz_i32          0
+#define TCG_TARGET_HAS_ctz_i32          0
+#define TCG_TARGET_HAS_ctpop_i32        0
+#define TCG_TARGET_HAS_clz_i64          0
+#define TCG_TARGET_HAS_ctz_i64          0
+#define TCG_TARGET_HAS_ctpop_i64        0
+
+// We don't have a simple gadget for this, since we're always assuming softmmu.
+#define TCG_TARGET_HAS_qemu_st8_i32     0
+
+// No AArch64 equivalent.a
+#define TCG_TARGET_HAS_extrl_i64_i32    0
+#define TCG_TARGET_HAS_extrh_i64_i32    0
+
+#define TCG_TARGET_HAS_extract2_i64     0
+
+// These should always be zero on our 64B platform.
+#define TCG_TARGET_HAS_muls2_i64        0
+#define TCG_TARGET_HAS_add2_i32         0
+#define TCG_TARGET_HAS_sub2_i32         0
+#define TCG_TARGET_HAS_mulu2_i32        0
+#define TCG_TARGET_HAS_add2_i64         0
+#define TCG_TARGET_HAS_sub2_i64         0
+#define TCG_TARGET_HAS_mulu2_i64        0
+#define TCG_TARGET_HAS_muluh_i64        0
+#define TCG_TARGET_HAS_mulsh_i64        0
+#define TCG_TARGET_HAS_extract2_i32     0
+#define TCG_TARGET_HAS_muls2_i32        0
+#define TCG_TARGET_HAS_muluh_i32        0
+#define TCG_TARGET_HAS_mulsh_i32        0
+
+//
+// Platform metadata.
+//
+
+// Number of registers available.
+// It might make sense to up these, since we can also use x16 -> x25?
+#define TCG_TARGET_NB_REGS 16
+
+/* List of registers which are used by TCG. */
+typedef enum {
+    TCG_REG_R0 = 0,
+    TCG_REG_R1,
+    TCG_REG_R2,
+    TCG_REG_R3,
+    TCG_REG_R4,
+    TCG_REG_R5,
+    TCG_REG_R6,
+    TCG_REG_R7,
+    TCG_REG_R8,
+    TCG_REG_R9,
+    TCG_REG_R10,
+    TCG_REG_R11,
+    TCG_REG_R12,
+    TCG_REG_R13,
+    TCG_REG_R14,
+    TCG_REG_R15,
+
+    TCG_AREG0          = TCG_REG_R14,
+    TCG_REG_CALL_STACK = TCG_REG_R15,
+} TCGReg;
+
+// Specify the shape of the stack our runtime will use.
+#define TCG_TARGET_CALL_STACK_OFFSET    0
+#define TCG_TARGET_STACK_ALIGN          16
+
+// We're interpreted, so we'll use our own code to run TB_EXEC.
+#define HAVE_TCG_QEMU_TB_EXEC
+
+// We'll need to enforce memory ordering with barriers.
+#define TCG_TARGET_DEFAULT_MO  (0)
+
+void tci_disas(uint8_t opc);
+
+void tb_target_set_jmp_target(uintptr_t, uintptr_t, uintptr_t, uintptr_t);
+
+
+#endif /* TCG_TARGET_H */
diff -ru --un qemu-7.2.0/tcg/aarch64-tcti/tcti-gadget-gen.py qemu-utm-7.2.0/tcg/aarch64-tcti/tcti-gadget-gen.py
--- qemu-7.2.0/tcg/aarch64-tcti/tcti-gadget-gen.py	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/tcg/aarch64-tcti/tcti-gadget-gen.py	2022-12-26 13:45:03
@@ -0,0 +1,788 @@
+#!/usr/bin/env python3
+""" Gadget-code generator for QEMU TCTI on AArch64. 
+
+Generates a C-code include file containing 'gadgets' for use by TCTI.
+"""
+
+import sys
+import itertools
+
+# Get a handle on the file we'll be working with, and redirect print to it.
+if len(sys.argv) > 1:
+    out_file = open(sys.argv[1], "w")
+
+    # Hook our print function, so it always outputs to the relevant file.
+    core_print = print
+    print = lambda *a, **k : core_print(*a, **k, file=out_file)
+
+# Epilogue code follows at the end of each gadget, and handles continuing execution.
+EPILOGUE = ( 
+    # Load our next gadget address from our bytecode stream, advancing it.
+    "ldr x27, [x28], #8",
+
+    # Jump to the next gadget.
+    "br x27"
+)
+
+# The number of general-purpose registers we're affording the TCG. This must match
+# the configuration in the TCTI target.
+TCG_REGISTER_COUNT   = 16
+TCG_REGISTER_NUMBERS = list(range(TCG_REGISTER_COUNT))
+
+# Helper that provides each of the AArch64 condition codes of interest.
+ARCH_CONDITION_CODES = ["eq", "ne", "lt", "ge", "le", "gt", "lo", "hs", "ls", "hi"]
+
+# We'll create a variety of gadgets that assume the MMU's TLB is stored at certain
+# offsets into its structure. These should match the offsets in tcg-target.c.in.
+QEMU_ALLOWED_MMU_OFFSETS = [ 64, 96, 128 ]
+
+# Statistics.
+gadgets      = 0
+instructions = 0
+
+def simple(name, *lines):
+    """ Generates a simple gadget that needs no per-register specialization. """
+
+    global gadgets, instructions
+
+    gadgets += 1
+
+    # Create our C/ASM framing.
+    #print(f"__attribute__((naked)) static void gadget_{name}(void)")
+    print(f"__attribute__((naked)) static void gadget_{name}(void);")
+    print(f"__attribute__((naked)) static void gadget_{name}(void)")
+    print("{")
+
+    # Add the core gadget
+    print("\tasm(")
+    for line in lines + EPILOGUE:
+        print(f"\t\t\"{line} \\n\"")
+        instructions += 1
+    print("\t);")
+
+    # End our framing.
+    print("}\n")
+
+
+def with_register_substitutions(name, substitutions, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgtes with register substitutions. """
+
+    def substitutions_for_letter(letter, number, line):
+        """ Helper that transforms Wd => w1, implementing gadget substitutions. """
+
+        # Register substitutions...
+        line = line.replace(f"X{letter}", f"x{number}")
+        line = line.replace(f"W{letter}", f"w{number}")
+
+        # ... immediate substitutions.
+        line = line.replace(f"I{letter}", f"{number}")
+        return line
+
+        
+    # Build a list of all the various stages we'll iterate over...
+    immediate_parameters = list(immediate_range)
+    parameters   = ([TCG_REGISTER_NUMBERS] * len(substitutions))
+
+    # ... adding immediates, if need be.
+    if immediate_parameters:
+        parameters.append(immediate_parameters)
+        substitutions = substitutions + ['i']
+
+    # Generate a list of register-combinations we'll support.
+    permutations = itertools.product(*parameters)
+
+    #  For each permutation...
+    for permutation in permutations:
+        new_lines = lines
+
+        # Replace each placeholder element with its proper value...
+        for index, element in enumerate(permutation):
+            letter = substitutions[index]
+            number = element
+
+            # Create new gadgets for the releavnt line...
+            new_lines = [substitutions_for_letter(letter, number, line) for line in new_lines]
+
+        # ... and emit the gadget.
+        permutation_id = "_arg".join(str(number) for number in permutation)
+        simple(f"{name}_arg{permutation_id}", *new_lines)
+
+
+def with_dnm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ("d", "n", "m"), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for m in TCG_REGISTER_NUMBERS:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{m}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_dn_immediate(name, *lines, immediate_range):
+    """ Generates a collection of gadgets with substitutions for Xd, Xn, and Xm, and equivalents. """
+    with_register_substitutions(name, ["d", "n"], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for d in TCG_REGISTER_NUMBERS:
+        print("\t{")
+
+        # N array
+        for n in TCG_REGISTER_NUMBERS:
+            print("\t\t{", end="")
+
+            # M array
+            for i in immediate_range:
+                print(f"gadget_{name}_arg{d}_arg{n}_arg{i}", end=", ")
+
+            print("},")
+        print("\t},")
+    print("};")
+
+
+def with_pair(name, substitutions, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, substitutions, *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    # N array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # M array
+        for b in TCG_REGISTER_NUMBERS:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+def math_dnm(name, mnemonic):
+    """ Equivalent to `with_dnm`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dnm(f'{name}_i32', f"{mnemonic} Wd, Wn, Wm")
+    with_dnm(f'{name}_i64', f"{mnemonic} Xd, Xn, Xm")
+
+def math_dn(name, mnemonic):
+    """ Equivalent to `with_dn`, but creates a _i32 and _i64 variant. For simple math. """
+    with_dn(f'{name}_i32', f"{mnemonic} Wd, Wn")
+    with_dn(f'{name}_i64', f"{mnemonic} Xd, Xn")
+
+
+def with_nm(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xn, and Xm, and equivalents. """
+    with_pair(name, ('n', 'm',), *lines)
+
+
+def with_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. """
+    with_pair(name, ('d', 'n',), *lines)
+
+
+def ldst_dn(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd, and Xn, and equivalents. 
+    
+    This variant is optimized for loads and stores, and optimizes common offset cases.
+    """
+
+    #
+    # Simple case: create our gadgets.
+    #
+    with_dn(name, "ldr x27, [x28], #8", *lines)
+
+    #
+    # Optimization case: create variants of our gadgets with our offsets replaced with common immediates.
+    #
+    immediate_lines_pos = [line.replace("x27", "#Ii") for line in lines]
+    with_dn_immediate(f"{name}_imm", *immediate_lines_pos, immediate_range=range(64))
+
+    immediate_lines_aligned = [line.replace("x27", "#(Ii << 3)") for line in lines]
+    with_dn_immediate(f"{name}_sh8_imm", *immediate_lines_aligned, immediate_range=range(64))
+
+    immediate_lines_neg = [line.replace("x27", "#-Ii") for line in lines]
+    with_dn_immediate(f"{name}_neg_imm", *immediate_lines_neg, immediate_range=range(64))
+
+
+def with_single(name, substitution, *lines):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, (substitution,), *lines)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}] = ", end="")
+    print("{")
+
+    for n in TCG_REGISTER_NUMBERS:
+        print(f"gadget_{name}_arg{n}", end=", ")
+
+    print("};")
+
+
+def with_d_immediate(name, *lines, immediate_range=range(0)):
+    """ Generates a collection of gadgets with two subtstitutions."""
+    with_register_substitutions(name, ['d'], *lines, immediate_range=immediate_range)
+
+    # Print out an array that contains all of our gadgets, for lookup.
+    print(f"static void* gadget_{name}[{TCG_REGISTER_COUNT}][{len(immediate_range)}] = ", end="")
+    print("{")
+
+    # D array
+    for a in TCG_REGISTER_NUMBERS:
+        print("\t\t{", end="")
+
+        # I array
+        for b in immediate_range:
+            print(f"gadget_{name}_arg{a}_arg{b}", end=", ")
+
+        print("},")
+    print("};")
+
+
+
+def with_d(name, *lines):
+    """ Generates a collection of gadgets with substitutions for Xd. """
+    with_single(name, 'd', *lines)
+
+
+# Assembly code for saving our machine state before entering the C runtime.
+C_CALL_PROLOGUE = [
+    # Store our machine state.
+    "str x25,      [sp, #-16]!",
+    "stp x14, x15, [sp, #-16]!",
+    "stp x12, x13, [sp, #-16]!",
+    "stp x10, x11, [sp, #-16]!",
+    "stp x8,  x9,  [sp, #-16]!",
+    "stp x6,  x7,  [sp, #-16]!",
+    "stp x4,  x5,  [sp, #-16]!",
+    "stp x2,  x3,  [sp, #-16]!",
+    "stp x0,  x1,  [sp, #-16]!",
+    "stp x28, lr,  [sp, #-16]!",
+]
+
+# Assembly code for restoring our machine state after leaving the C runtime.
+C_CALL_EPILOGUE = [
+    "ldp x28, lr, [sp], #16",
+    "ldp x0,  x1, [sp], #16",
+    "ldp x2,  x3, [sp], #16",
+    "ldp x4,  x5, [sp], #16",
+    "ldp x6,  x7, [sp], #16",
+    "ldp x8,  x9, [sp], #16",
+    "ldp x10, x11, [sp], #16",
+    "ldp x12, x13, [sp], #16",
+    "ldp x14, x15, [sp], #16",
+    "ldr x25,      [sp], #16",
+]
+
+
+def create_tlb_fastpath(is_aligned, is_write, offset, miss_label="0"):
+    """ Creates a set of instructions that perform a soft-MMU TLB lookup.
+
+    This is used for `qemu_ld`/qemu_st` instructions; to emit a prologue that
+    hopefully helps us skip a slow call into the C runtime when a Guest Virtual 
+    -> Host Virtual mapping is in the softmmu's TLB.
+
+    This "fast-path" prelude behaves as follows:
+        - If a TLB entry is found for the address stored in Xn, then x27
+          is stored to an "addend" that can be added to the guest virtual addres
+          to get the host virtual address (the address in our local memory space).
+        - If a TLB entry isn't found, it branches to the "miss_label" (by default, 0:),
+          so address lookup can be handled by the fastpath.
+
+    Clobbers x24, and x26; provides output in x27.
+    """
+
+    fast_path = [
+        # Load env_tlb(env)->f[mmu_idx].{mask,table} into {x26,x27}.
+        f"ldp x26, x27, [x14, #-{offset}]",
+
+        # Extract the TLB index from the address into X26. 
+        "and x26, x26, Xn, lsr #7", # Xn = addr regsiter 
+
+        # Add the tlb_table pointer, creating the CPUTLBEntry address into X27. 
+        "add x27, x27, x26",
+
+        # Load the tlb comparator into X26, and the fast path addend into X27. 
+        "ldr x26, [x27, #8]" if is_write else "ldr x26, [x27]",
+        "ldr x27, [x27, #0x18]",
+
+    ]
+
+    if is_aligned:
+        fast_path.extend([
+            # Store the page mask part of the address into X24.
+            "and x24, Xn, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+    else:
+        fast_path.extend([
+            # If we're not aligned, add in our alignment value to ensure we don't
+            # don't straddle the end of a page.
+            "add x24, Xn, #7",
+
+            # Store the page mask part of the address into X24.
+            "and x24, x24, #0xfffffffffffff000",
+
+            # Compare the masked address with the TLB value.
+            "cmp x26, x24",
+
+            # If we're not equal, this isn't a TLB hit. Jump to our miss handler.
+            f"b.ne {miss_label}f",
+        ])
+
+    return fast_path
+
+
+
+def ld_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=False, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            # Otherwise, we'll save arguments for our slow path.
+            else:
+                fastpath_ops = []
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    "mov x27, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Placed in x27 below.]
+                    # - Move our operation info into x2, from an immediate32.
+                    # - Move the next bytecode pointer into x3, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x27",
+                    f"mov   x2, #{immediate}" if (immediate is not None) else "ldr   x2, [x28], #8", 
+                    "mov   x3, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Temporarily store our result in a register that won't get trashed.
+                    "mov x27, x0",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript...
+                    *postscript,
+
+                    # ... and place our results in the target register.
+                    "mov Wd, w27" if is_32b else "mov Xd, x27"
+            )
+
+
+def st_thunk(name, fastpath_32b, fastpath_64b, slowpath_helper, immediate=None, is_aligned=False, force_slowpath=False):
+    """ Creates a thunk into our C runtime for a QEMU ST operation. """
+
+    # Use only offset 0 (no real offset) if we're forcing slowpath; 
+    # otherwise, use all of our allowed MMU offsets.
+    offsets = [0] if force_slowpath else QEMU_ALLOWED_MMU_OFFSETS
+    for offset in offsets:
+
+        for is_32b in (True, False):
+            fastpath = fastpath_32b if is_32b else fastpath_64b
+
+            gadget_name = f"{name}_off{offset}_i32" if is_32b else f"{name}_off{offset}_i64"
+            postscript = () if immediate else ("add x28, x28, #8",)
+
+            # If we have a pure-assembly fast path, start our gadget with it.
+            if fastpath and not force_slowpath:
+                fastpath_ops = [
+
+                    # Create a fastpath that jumps to miss_lable on a TLB miss,
+                    # or sets x27 to the TLB addend on a TLB hit.
+                    *create_tlb_fastpath(is_aligned=is_aligned, is_write=True, offset=offset),
+
+                    # On a hit, we can just perform an appropriate load...
+                    *fastpath,
+
+                    # Run our patch-up post-script, if we have one.
+                    *postscript,
+
+                    # ... and then we're done!
+                    *EPILOGUE,
+                ]
+            else:
+                fastpath_ops = []
+
+
+            #
+            # If we're not taking our fast path, we'll call into our C runtime to take the slow path.
+            # 
+            with_dn(gadget_name, 
+                    *fastpath_ops,
+
+                "0:",
+                    # Move our arguments into registers that we're not actively using.
+                    # This ensures that they won't be trounced by our calling convention
+                    # if this is reading values from x0-x4.
+                    "mov w27, Wd" if is_32b else "mov x27, Xd",
+                    "mov x26, Xn",
+
+                    # Save our registers in preparation for entering a C call.
+                    *C_CALL_PROLOGUE,
+
+                    # Per our calling convention:
+                    # - Move our architectural environment into x0, from x14.
+                    # - Move our target address into x1. [Moved into x26 above].
+                    # - Move our target value into x2. [Moved into x27 above].
+                    # - Move our operation info into x3, from an immediate32.
+                    # - Move the next bytecode pointer into x4, from x28.
+                    "mov   x0, x14",
+                    "mov   x1, x26",
+                    "mov   x2, x27",
+                    f"mov  x3, #{immediate}" if (immediate is not None) else "ldr   x3, [x28], #8", 
+                    "mov   x4, x28",
+
+                    # Perform our actual core code.
+                    f"bl _{slowpath_helper}",
+
+                    # Restore our registers after our C call.
+                    *C_CALL_EPILOGUE,
+
+                    # Finally, call our postscript.
+                    *postscript
+            )
+
+
+#
+# Gadget definitions.
+#
+
+print("/* Automatically generated by tcti-gadget-gen.py. Do not edit. */\n")
+
+# Call a C language helper function by address.
+simple("call",
+    # Get our C runtime function's location as a pointer-sized immediate...
+    "ldr x27, [x28], #8",
+
+    # Store our TB return address for our helper.
+    "str x28, [x25]",
+
+    # Prepare ourselves to call into our C runtime...
+    *C_CALL_PROLOGUE,
+
+    # ... perform the call itself ...
+    "blr x27",
+
+    # Save the result of our call for later.
+    "mov x27, x0",
+
+    # ... and restore our environment.
+    *C_CALL_EPILOGUE,
+
+    # Restore our return value.
+    "mov x0, x27"
+)
+
+# Branch to a given immediate address.
+simple("br",
+    # Use our immediate argument as our new bytecode-pointer location.
+    "ldr x28, [x28]"
+)
+
+# Exit from a translation buffer execution.
+simple("exit_tb",
+
+    # We have a single immediate argument, which contains our return code.
+    # Place it into x0, as one would a return code.
+    "ldr x0, [x28], #8",
+
+    # And finally, return back to the code that invoked our gadget stream.
+    "ret"
+)
+
+
+for condition in ARCH_CONDITION_CODES:
+
+    # Performs a comparison between two operands.
+    with_dnm(f"setcond_i32_{condition}",
+        "subs Wd, Wn, Wm",
+        f"cset Wd, {condition}"
+    )
+    with_dnm(f"setcond_i64_{condition}",
+        "subs Xd, Xn, Xm",
+        f"cset Xd, {condition}"
+    )
+
+    #
+    # NOTE: we use _dnm for the conditional branches, even though we don't
+    # actually do anything different based on the d argument. This gemerates
+    # effectively 16 identical `brcond` gadgets for each condition; which we
+    # use in the backend to spread out the actual branch sources we use.
+    #
+    # This is a slight mercy for the branch predictor, as not every conditional
+    # branch is funneled throught the same address.
+    #
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i32_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Wzr, Wn, Wm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+           # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+    # Branches iff a given comparison is true.
+    with_dnm(f'brcond_i64_{condition}',
+
+        # Grab our immediate argument.
+        "ldr x27, [x28], #8",
+
+        # Perform our comparison and conditional branch.
+        "subs Xzr, Xn, Xm",
+        f"b{condition} 1f",
+
+        "0:", # not taken
+            # Perform our end-of-instruction epilogue.
+            *EPILOGUE,
+
+        "1:" # taken
+            # Update our bytecode pointer to take the label.
+            "mov x28, x27"
+    )
+
+
+# MOV variants.
+with_dn("mov_i32",     "mov Wd, Wn")
+with_dn("mov_i64",     "mov Xd, Xn")
+with_d("movi_i32", "ldr Wd, [x28], #8")
+with_d("movi_i64", "ldr Xd, [x28], #8")
+
+# Create MOV variants that have common constants built in to the gadget.
+# This optimization helps costly reads from memories for simple operations.
+with_d_immediate("movi_imm_i32", "mov Wd, #Ii", immediate_range=range(64))
+with_d_immediate("movi_imm_i64", "mov Xd, #Ii", immediate_range=range(64))
+
+# LOAD variants.
+# TODO: should the signed variants have X variants for _i64?
+ldst_dn("ld8u",      "ldrb  Wd, [Xn, x27]")
+ldst_dn("ld8s_i32",  "ldrsb Wd, [Xn, x27]")
+ldst_dn("ld8s_i64",  "ldrsb Xd, [Xn, x27]")
+ldst_dn("ld16u",     "ldrh  Wd, [Xn, x27]")
+ldst_dn("ld16s_i32", "ldrsh Wd, [Xn, x27]")
+ldst_dn("ld16s_i64", "ldrsh Xd, [Xn, x27]")
+ldst_dn("ld32u",     "ldr   Wd, [Xn, x27]")
+ldst_dn("ld32s_i64", "ldrsw Xd, [Xn, x27]")
+ldst_dn("ld_i64",    "ldr   Xd, [Xn, x27]")
+
+# STORE variants.
+ldst_dn("st8",         "strb  Wd, [Xn, x27]")
+ldst_dn("st16",        "strh  Wd, [Xn, x27]")
+ldst_dn("st_i32",      "str   Wd, [Xn, x27]")
+ldst_dn("st_i64",      "str   Xd, [Xn, x27]")
+
+# QEMU LD/ST are handled in our C runtime rather than with simple gadgets,
+# as they're nontrivial.
+
+# Trivial arithmetic.
+math_dnm("add" , "add" )
+math_dnm("sub" , "sub" )
+math_dnm("mul" , "mul" )
+math_dnm("div" , "sdiv")
+math_dnm("divu", "udiv")
+
+# Division remainder
+with_dnm("rem_i32",  "sdiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("rem_i64",  "sdiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+with_dnm("remu_i32", "udiv w27, Wn, Wm", "msub Wd, w27, Wm, Wn")
+with_dnm("remu_i64", "udiv x27, Xn, Xm", "msub Xd, x27, Xm, Xn")
+
+# Trivial logical.
+math_dn( "not",  "mvn")
+math_dn( "neg",  "neg")
+math_dnm("and",  "and")
+math_dnm("andc", "bic")
+math_dnm("or",   "orr")
+math_dnm("orc",  "orn")
+math_dnm("xor",  "eor")
+math_dnm("eqv",  "eon")
+math_dnm("shl",  "lsl")
+math_dnm("shr",  "lsr")
+math_dnm("sar",  "asr")
+
+# AArch64 lacks a Rotate Left; so we instead rotate right by a negative.
+# TODO: validate this?
+#math_dnm("rotr", "ror")
+#with_dnm("rotl_i32", "neg w27, Wm", "ror Wd, Wn, w27")
+#with_dnm("rotl_i64", "neg x27, Xm", "ror Xd, Xn, x27")
+
+# Numeric extension.
+math_dn("ext8s",      "sxtb")
+with_dn("ext8u",      "and Xd, Xn, #0xff")
+math_dn("ext16s",     "sxth")
+with_dn("ext16u",     "and Wd, Wn, #0xffff")
+with_dn("ext32s_i64", "sxtw Xd, Wn")
+with_dn("ext32u_i64", "and Xd, Xn, #0xffffffff")
+
+# Byte swapping.
+with_dn("bswap16",    "rev w27, Wn", "lsr Wd, w27, #16")
+with_dn("bswap32",    "rev Wd, Wn")
+with_dn("bswap64",    "rev Xd, Xn")
+
+# Memory barriers.
+simple("mb_all", "dmb ish")
+simple("mb_st",  "dmb ishst")
+simple("mb_ld",  "dmb ishld")
+
+# Handlers for QEMU_LD, which handles guest <- host loads.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    ld_thunk(f"qemu_ld_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu",
+        fastpath_32b=["ldrb Wd, [Xn, x27]"], fastpath_64b=["ldrb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_sb_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_ldub_mmu_signed",
+        fastpath_32b=["ldrsb Wd, [Xn, x27]"], fastpath_64b=["ldrsb Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu",
+        fastpath_32b=["ldrh Wd, [Xn, x27]"], fastpath_64b=["ldrh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_lduw_mmu_signed",
+        fastpath_32b=["ldrsh Wd, [Xn, x27]"], fastpath_64b=["ldrsh Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu",
+        fastpath_32b=["ldr Wd, [Xn, x27]"], fastpath_64b=["ldr Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_lesl_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldul_mmu_signed",
+        fastpath_32b=["ldrsw Xd, [Xn, x27]"], fastpath_64b=["ldrsw Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    ld_thunk(f"qemu_ld_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+
+    # Special variant for the most common mode, as a speedup optimization.
+    ld_thunk(f"qemu_ld_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_ldq_mmu",
+        fastpath_32b=["ldr Xd, [Xn, x27]"], fastpath_64b=["ldr Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    ld_thunk(f"qemu_ld_beuw_{subtype}", None, None, "helper_be_lduw_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besw_{subtype}", None, None, "helper_be_lduw_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beul_{subtype}", None, None, "helper_be_ldul_mmu",         
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_besl_{subtype}", None, None, "helper_be_ldul_mmu_signed",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    ld_thunk(f"qemu_ld_beq_{subtype}",  None, None, "helper_be_ldq_mmu",          
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Handlers for QEMU_ST, which handles guest -> host stores.
+for subtype in ('aligned', 'unaligned', 'slowpath'):
+    is_aligned  = (subtype == 'aligned')
+    is_slowpath = (subtype == 'slowpath')
+
+    st_thunk(f"qemu_st_ub_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_ret_stb_mmu",
+        fastpath_32b=["strb Wd, [Xn, x27]"], fastpath_64b=["strb Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leuw_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stw_mmu",
+        fastpath_32b=["strh Wd, [Xn, x27]"], fastpath_64b=["strh Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leul_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stl_mmu",
+        fastpath_32b=["str Wd, [Xn, x27]"], fastpath_64b=["str Wd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    st_thunk(f"qemu_st_leq_{subtype}", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath,
+    )
+    
+    # Special optimization for the most common modes.
+    st_thunk(f"qemu_st_leq_{subtype}_mode3a", is_aligned=is_aligned, slowpath_helper="helper_le_stq_mmu",
+        fastpath_32b=["str Xd, [Xn, x27]"], fastpath_64b=["str Xd, [Xn, x27]"],
+        force_slowpath=is_slowpath, immediate=0x3a
+    )
+
+    # For now, leave the rare/big-endian stuff slow-path only.
+    st_thunk(f"qemu_st_beuw_{subtype}", None, None, "helper_be_stw_mmu",  
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beul_{subtype}", None, None, "helper_be_stl_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+    st_thunk(f"qemu_st_beq_{subtype}",  None, None, "helper_be_stq_mmu",
+            is_aligned=is_aligned, force_slowpath=is_slowpath)
+
+
+# Statistics.
+sys.stderr.write(f"\nGenerated {gadgets} gadgets with {instructions} instructions ({instructions * 4} B).\n\n")
diff -ru --un qemu-7.2.0/tcg/region.c qemu-utm-7.2.0/tcg/region.c
--- qemu-7.2.0/tcg/region.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/tcg/region.c	2022-12-26 13:45:03
@@ -544,7 +544,7 @@
     return prot;
 }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 #ifdef CONFIG_POSIX
 #include "qemu/memfd.h"
 
@@ -648,7 +648,7 @@
 
 static int alloc_code_gen_buffer_splitwx(size_t size, Error **errp)
 {
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 # ifdef CONFIG_DARWIN
     return alloc_code_gen_buffer_splitwx_vmremap(size, errp);
 # endif
@@ -688,7 +688,10 @@
      */
     prot = PROT_NONE;
     flags = MAP_PRIVATE | MAP_ANONYMOUS;
-#ifdef CONFIG_DARWIN
+#if defined(CONFIG_TCG_INTERPRETER) || defined(CONFIG_TCG_THREADED_INTERPRETER)
+    /* The tcg interpreter does not need execute permission. */
+    prot = PROT_READ | PROT_WRITE;
+#elif defined(CONFIG_DARWIN)
     /* Applicable to both iOS and macOS (Apple Silicon). */
     if (!splitwx) {
         flags |= MAP_JIT;
@@ -794,7 +797,7 @@
      * Work with the page protections set up with the initial mapping.
      */
     need_prot = PAGE_READ | PAGE_WRITE;
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     if (tcg_splitwx_diff == 0) {
         need_prot |= PAGE_EXEC;
     }
diff -ru --un qemu-7.2.0/tcg/tcg.c qemu-utm-7.2.0/tcg/tcg.c
--- qemu-7.2.0/tcg/tcg.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/tcg/tcg.c	2022-12-26 13:45:03
@@ -44,6 +44,7 @@
 #define NO_CPU_IO_DEFS
 
 #include "exec/exec-all.h"
+#include "tcg/tcg-apple-jit.h"
 #include "tcg/tcg-op.h"
 
 #if UINTPTR_MAX == UINT32_MAX
@@ -170,7 +171,7 @@
 const void *tcg_code_gen_epilogue;
 uintptr_t tcg_splitwx_diff;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
 tcg_prologue_fn *tcg_qemu_tb_exec;
 #endif
 
@@ -728,7 +729,7 @@
     s->code_buf = s->code_gen_ptr;
     s->data_gen_ptr = NULL;
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     tcg_qemu_tb_exec = (tcg_prologue_fn *)tcg_splitwx_to_rx(s->code_ptr);
 #endif
 
@@ -750,7 +751,7 @@
 
     prologue_size = tcg_current_code_size(s);
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(s->code_buf),
                         (uintptr_t)s->code_buf, prologue_size);
 #endif
@@ -789,7 +790,7 @@
     }
 #endif
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /*
      * Assert that goto_ptr is implemented completely, setting an epilogue.
      * For tci, we use NULL as the signal to return from the interpreter,
@@ -1188,13 +1189,19 @@
     case INDEX_op_insn_start:
     case INDEX_op_exit_tb:
     case INDEX_op_goto_tb:
-    case INDEX_op_goto_ptr:
     case INDEX_op_qemu_ld_i32:
     case INDEX_op_qemu_st_i32:
     case INDEX_op_qemu_ld_i64:
     case INDEX_op_qemu_st_i64:
         return true;
 
+    case INDEX_op_goto_ptr:
+#if defined(CONFIG_TCG_THREADED_INTERPRETER)
+        return false;
+#else
+        return true;
+#endif
+
     case INDEX_op_qemu_st8_i32:
         return TCG_TARGET_HAS_qemu_st8_i32;
 
@@ -4351,7 +4358,7 @@
         return -2;
     }
 
-#ifndef CONFIG_TCG_INTERPRETER
+#if !defined(CONFIG_TCG_INTERPRETER) && !defined(CONFIG_TCG_THREADED_INTERPRETER)
     /* flush instruction cache */
     flush_idcache_range((uintptr_t)tcg_splitwx_to_rx(s->code_buf),
                         (uintptr_t)s->code_buf,
diff -ru --un qemu-7.2.0/ui/console-gl.c qemu-utm-7.2.0/ui/console-gl.c
--- qemu-7.2.0/ui/console-gl.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/console-gl.c	2022-12-26 13:45:04
@@ -56,8 +56,9 @@
     switch (surface->format) {
     case PIXMAN_BE_b8g8r8x8:
     case PIXMAN_BE_b8g8r8a8:
-        surface->glformat = GL_BGRA_EXT;
+        surface->glformat = GL_RGBA;
         surface->gltype = GL_UNSIGNED_BYTE;
+        surface->glswapped = true;
         break;
     case PIXMAN_BE_x8r8g8b8:
     case PIXMAN_BE_a8r8g8b8:
@@ -125,7 +126,7 @@
     glClearColor(0.1f, 0.1f, 0.1f, 0.0f);
     glClear(GL_COLOR_BUFFER_BIT);
 
-    qemu_gl_run_texture_blit(gls, false);
+    qemu_gl_run_texture_blit(gls, false, false);
 }
 
 void surface_gl_destroy_texture(QemuGLShader *gls,
diff -ru --un qemu-7.2.0/ui/console.c qemu-utm-7.2.0/ui/console.c
--- qemu-7.2.0/ui/console.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/console.c	2022-12-26 13:45:04
@@ -1213,9 +1213,7 @@
                dcl->ops->dpy_gl_scanout_texture) {
         dcl->ops->dpy_gl_scanout_texture(dcl,
                                          con->scanout.texture.backing_id,
-                                         con->scanout.texture.backing_y_0_top,
-                                         con->scanout.texture.backing_width,
-                                         con->scanout.texture.backing_height,
+                                         con->scanout.texture.backing_borrow,
                                          con->scanout.texture.x,
                                          con->scanout.texture.y,
                                          con->scanout.texture.width,
@@ -1659,6 +1626,9 @@
         con = active_console;
     }
     displaychangelistener_display_console(dcl, con, dcl->con ? &error_fatal : NULL);
+    if (dcl->ds->have_text) {
+        dpy_text_resize(dcl->con, dcl->con->width, dcl->con->height);
+    }
     text_console_update_cursor(NULL);
 }
 
@@ -1986,9 +1956,7 @@
 
 void dpy_gl_scanout_texture(QemuConsole *con,
                             uint32_t backing_id,
-                            bool backing_y_0_top,
-                            uint32_t backing_width,
-                            uint32_t backing_height,
+                            DisplayGLTextureBorrower backing_borrow,
                             uint32_t x, uint32_t y,
                             uint32_t width, uint32_t height)
 {
@@ -1997,7 +1965,7 @@
 
     con->scanout.kind = SCANOUT_TEXTURE;
     con->scanout.texture = (ScanoutTexture) {
-        backing_id, backing_y_0_top, backing_width, backing_height,
+        backing_id, backing_borrow,
         x, y, width, height
     };
     QLIST_FOREACH(dcl, &s->listeners, next) {
@@ -2005,9 +1973,7 @@
             continue;
         }
         if (dcl->ops->dpy_gl_scanout_texture) {
-            dcl->ops->dpy_gl_scanout_texture(dcl, backing_id,
-                                             backing_y_0_top,
-                                             backing_width, backing_height,
+            dcl->ops->dpy_gl_scanout_texture(dcl, backing_id, backing_borrow,
                                              x, y, width, height);
         }
     }
@@ -2210,6 +2176,18 @@
     dpy_gfx_replace_surface(con, surface);
 }
 
+QemuConsole *qemu_console_lookup_first_graphic_console(void)
+{
+    QemuConsole *con;
+
+    QTAILQ_FOREACH(con, &consoles, next) {
+        if (con->console_type == GRAPHIC_CONSOLE) {
+            return con;
+        }
+    }
+    return NULL;
+}
+
 QemuConsole *qemu_console_lookup_by_index(unsigned int index)
 {
     QemuConsole *con;
@@ -2592,12 +2570,7 @@
 
 DisplaySurface *qemu_console_surface(QemuConsole *console)
 {
-    switch (console->scanout.kind) {
-    case SCANOUT_SURFACE:
-        return console->surface;
-    default:
-        return NULL;
-    }
+    return console->surface;
 }
 
 PixelFormat qemu_default_pixelformat(int bpp)
diff -ru --un qemu-7.2.0/ui/curses.c qemu-utm-7.2.0/ui/curses.c
--- qemu-7.2.0/ui/curses.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/curses.c	2022-12-26 13:45:04
@@ -98,7 +98,7 @@
 
 static void curses_calc_pad(void)
 {
-    if (qemu_console_is_fixedsize(NULL)) {
+    if (qemu_console_is_fixedsize(dcl->con)) {
         width = gwidth;
         height = gheight;
     } else {
@@ -201,7 +201,7 @@
             curs_set(1);
             /* it seems that curs_set(1) must always be called before
              * curs_set(2) for the latter to have effect */
-            if (!qemu_console_is_graphic(NULL)) {
+            if (!qemu_console_is_graphic(dcl->con)) {
                 curs_set(2);
             }
             return;
@@ -274,11 +274,11 @@
         clear();
         refresh();
         curses_calc_pad();
-        graphic_hw_invalidate(NULL);
+        graphic_hw_invalidate(dcl->con);
         invalidate = 0;
     }
 
-    graphic_hw_text_update(NULL, screen);
+    graphic_hw_text_update(dcl->con, screen);
 
     while (1) {
         /* while there are any pending key strokes to process */
@@ -318,11 +318,16 @@
                     /* process keys reserved for qemu */
                     if (keycode >= QEMU_KEY_CONSOLE0 &&
                             keycode < QEMU_KEY_CONSOLE0 + 9) {
-                        erase();
-                        wnoutrefresh(stdscr);
-                        console_select(keycode - QEMU_KEY_CONSOLE0);
+                        QemuConsole *con = qemu_console_lookup_by_index(keycode - QEMU_KEY_CONSOLE0);
+                        if (con) {
+                            erase();
+                            wnoutrefresh(stdscr);
+                            unregister_displaychangelistener(dcl);
+                            dcl->con = con;
+                            register_displaychangelistener(dcl);
 
-                        invalidate = 1;
+                            invalidate = 1;
+                        }
                         continue;
                     }
                 }
@@ -354,45 +359,45 @@
         if (keycode == -1)
             continue;
 
-        if (qemu_console_is_graphic(NULL)) {
+        if (qemu_console_is_graphic(dcl->con)) {
             /* since terminals don't know about key press and release
              * events, we need to emit both for each key received */
             if (keycode & SHIFT) {
-                qemu_input_event_send_key_number(NULL, SHIFT_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, SHIFT_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & CNTRL) {
-                qemu_input_event_send_key_number(NULL, CNTRL_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, CNTRL_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & ALT) {
-                qemu_input_event_send_key_number(NULL, ALT_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, ALT_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & ALTGR) {
-                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, true);
+                qemu_input_event_send_key_number(dcl->con, GREY | ALT_CODE, true);
                 qemu_input_event_send_key_delay(0);
             }
 
-            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, true);
+            qemu_input_event_send_key_number(dcl->con, keycode & KEY_MASK, true);
             qemu_input_event_send_key_delay(0);
-            qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, false);
+            qemu_input_event_send_key_number(dcl->con, keycode & KEY_MASK, false);
             qemu_input_event_send_key_delay(0);
 
             if (keycode & ALTGR) {
-                qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, GREY | ALT_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & ALT) {
-                qemu_input_event_send_key_number(NULL, ALT_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, ALT_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & CNTRL) {
-                qemu_input_event_send_key_number(NULL, CNTRL_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, CNTRL_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
             if (keycode & SHIFT) {
-                qemu_input_event_send_key_number(NULL, SHIFT_CODE, false);
+                qemu_input_event_send_key_number(dcl->con, SHIFT_CODE, false);
                 qemu_input_event_send_key_delay(0);
             }
         } else {
@@ -400,7 +405,7 @@
             if (keysym == -1)
                 keysym = chr;
 
-            kbd_put_keysym(keysym);
+            kbd_put_keysym_console(dcl->con, keysym);
         }
     }
 }
@@ -798,6 +803,7 @@
     curses_winch_init();
 
     dcl = g_new0(DisplayChangeListener, 1);
+    dcl->con = qemu_console_lookup_first_graphic_console();
     dcl->ops = &dcl_ops;
     register_displaychangelistener(dcl);
 
diff -ru --un qemu-7.2.0/ui/dbus-listener.c qemu-utm-7.2.0/ui/dbus-listener.c
--- qemu-7.2.0/ui/dbus-listener.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/dbus-listener.c	2022-12-26 13:45:04
@@ -113,13 +113,11 @@
         NULL, NULL, NULL);
 }
 
-static void dbus_scanout_texture(DisplayChangeListener *dcl,
-                                 uint32_t tex_id,
-                                 bool backing_y_0_top,
-                                 uint32_t backing_width,
-                                 uint32_t backing_height,
-                                 uint32_t x, uint32_t y,
-                                 uint32_t w, uint32_t h)
+static void dbus_scanout_borrowed_texture(DisplayChangeListener *dcl,
+                                          uint32_t tex_id,
+                                          bool backing_y_0_top,
+                                          uint32_t backing_width,
+                                          uint32_t backing_height)
 {
     QemuDmaBuf dmabuf = {
         .width = backing_width,
@@ -141,6 +139,22 @@
     close(dmabuf.fd);
 }
 
+static void dbus_scanout_texture(DisplayChangeListener *dcl,
+                                 uint32_t backing_id,
+                                 DisplayGLTextureBorrower backing_borrow,
+                                 uint32_t x, uint32_t y,
+                                 uint32_t w, uint32_t h)
+{
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+    uint32_t tex_id = backing_borrow(backing_id, &backing_y_0_top,
+                                     &backing_width, &backing_height);
+
+    dbus_scanout_borrowed_texture(dcl, tex_id, backing_y_0_top,
+                                  backing_width, backing_height);
+}
+
 static void dbus_cursor_dmabuf(DisplayChangeListener *dcl,
                                QemuDmaBuf *dmabuf, bool have_hot,
                                uint32_t hot_x, uint32_t hot_y)
@@ -306,8 +320,8 @@
         int height = surface_height(ddl->ds);
 
         /* TODO: lazy send dmabuf (there are unnecessary sent otherwise) */
-        dbus_scanout_texture(&ddl->dcl, ddl->ds->texture, false,
-                             width, height, 0, 0, width, height);
+        dbus_scanout_borrowed_texture(&ddl->dcl, ddl->ds->texture, false,
+                                      width, height);
     }
 }
 
diff -ru --un qemu-7.2.0/ui/egl-headless.c qemu-utm-7.2.0/ui/egl-headless.c
--- qemu-7.2.0/ui/egl-headless.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/egl-headless.c	2022-12-26 13:45:04
@@ -18,6 +18,10 @@
     uint32_t pos_y;
 } egl_dpy;
 
+#ifndef CONFIG_GBM
+static EGLContext ctx;
+#endif
+
 /* ------------------------------------------------------------------ */
 
 static void egl_refresh(DisplayChangeListener *dcl)
@@ -41,8 +45,12 @@
 static QEMUGLContext egl_create_context(DisplayGLCtx *dgc,
                                         QEMUGLParams *params)
 {
+#ifdef CONFIG_GBM
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    qemu_egl_rn_ctx);
+#else
+    eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE, ctx);
+#endif
     return qemu_egl_create_context(dgc, params);
 }
 
@@ -54,13 +62,11 @@
     egl_fb_destroy(&edpy->blit_fb);
 }
 
-static void egl_scanout_texture(DisplayChangeListener *dcl,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h)
+static void egl_scanout_imported_texture(DisplayChangeListener *dcl,
+                                         uint32_t backing_texture,
+                                         bool backing_y_0_top,
+                                         uint32_t backing_width,
+                                         uint32_t backing_height)
 {
     egl_dpy *edpy = container_of(dcl, egl_dpy, dcl);
 
@@ -68,7 +74,7 @@
 
     /* source framebuffer */
     egl_fb_setup_for_tex(&edpy->guest_fb,
-                         backing_width, backing_height, backing_id, false);
+                         backing_width, backing_height, backing_texture, false);
 
     /* dest framebuffer */
     if (edpy->blit_fb.width  != backing_width ||
@@ -78,17 +84,32 @@
     }
 }
 
-static void egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                               QemuDmaBuf *dmabuf)
+static void egl_scanout_texture(DisplayChangeListener *dcl,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrow,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
 {
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    egl_scanout_imported_texture(dcl, backing_texture, backing_y_0_top,
+                                 backing_width, backing_height);
+}
+
+#ifdef CONFIG_GBM
+static void egl_scanout_dmabuf(DisplayChangeListener *dcl, QemuDmaBuf *dmabuf)
+{
     egl_dmabuf_import_texture(dmabuf);
     if (!dmabuf->texture) {
         return;
     }
 
-    egl_scanout_texture(dcl, dmabuf->texture,
-                        false, dmabuf->width, dmabuf->height,
-                        0, 0, dmabuf->width, dmabuf->height);
+    egl_scanout_imported_texture(dcl, dmabuf->texture,
+                                 false, dmabuf->width, dmabuf->height);
 }
 
 static void egl_cursor_dmabuf(DisplayChangeListener *dcl,
@@ -123,6 +144,7 @@
 {
     egl_dmabuf_release_texture(dmabuf);
 }
+#endif
 
 static void egl_scanout_flush(DisplayChangeListener *dcl,
                               uint32_t x, uint32_t y,
@@ -138,9 +160,9 @@
     if (edpy->cursor_fb.texture) {
         /* have cursor -> render using textures */
         egl_texture_blit(edpy->gls, &edpy->blit_fb, &edpy->guest_fb,
-                         !edpy->y_0_top);
+                         !edpy->y_0_top, false);
         egl_texture_blend(edpy->gls, &edpy->blit_fb, &edpy->cursor_fb,
-                          !edpy->y_0_top, edpy->pos_x, edpy->pos_y,
+                          false, !edpy->y_0_top, edpy->pos_x, edpy->pos_y,
                           1.0, 1.0);
     } else {
         /* no cursor -> use simple framebuffer blit */
@@ -159,10 +181,12 @@
 
     .dpy_gl_scanout_disable  = egl_scanout_disable,
     .dpy_gl_scanout_texture  = egl_scanout_texture,
+#ifdef CONFIG_GBM
     .dpy_gl_scanout_dmabuf   = egl_scanout_dmabuf,
     .dpy_gl_cursor_dmabuf    = egl_cursor_dmabuf,
     .dpy_gl_cursor_position  = egl_cursor_position,
     .dpy_gl_release_dmabuf   = egl_release_dmabuf,
+#endif
     .dpy_gl_update           = egl_scanout_flush,
 };
 
@@ -200,10 +224,23 @@
     egl_dpy *edpy;
     int idx;
 
+#ifdef CONFIG_GBM
     if (egl_rendernode_init(opts->u.egl_headless.rendernode, mode) < 0) {
         error_report("egl: render node init failed");
         exit(1);
     }
+#else
+    if (qemu_egl_init_dpy_surfaceless(mode)) {
+        error_report("egl: display init failed");
+        exit(1);
+    }
+
+    ctx = qemu_egl_init_ctx();
+    if (!ctx) {
+        error_report("egl: egl_init_ctx failed");
+        exit(1);
+    }
+#endif
 
     for (idx = 0;; idx++) {
         DisplayGLCtx *ctx;
diff -ru --un qemu-7.2.0/ui/egl-helpers.c qemu-utm-7.2.0/ui/egl-helpers.c
--- qemu-7.2.0/ui/egl-helpers.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/egl-helpers.c	2022-12-26 13:45:48
@@ -58,14 +58,15 @@
     fb->framebuffer = 0; /* default framebuffer */
 }
 
-void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
-                          GLuint texture, bool delete)
+void egl_fb_setup_for_tex_target(egl_fb *fb, int width, int height,
+                                 GLuint texture, GLenum target, bool delete)
 {
     egl_fb_delete_texture(fb);
 
     fb->width = width;
     fb->height = height;
     fb->texture = texture;
+    fb->texture_target = target;
     fb->delete_texture = delete;
     if (!fb->framebuffer) {
         glGenFramebuffers(1, &fb->framebuffer);
@@ -73,21 +74,32 @@
 
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, fb->framebuffer);
     glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,
-                              GL_TEXTURE_2D, fb->texture, 0);
+                              fb->texture_target, fb->texture, 0);
 }
 
-void egl_fb_setup_new_tex(egl_fb *fb, int width, int height)
+void egl_fb_setup_for_tex(egl_fb *fb, int width, int height,
+                          GLuint texture, bool delete)
 {
+    egl_fb_setup_for_tex_target(fb, width, height, texture, GL_TEXTURE_2D, delete);
+}
+
+void egl_fb_setup_new_tex_target(egl_fb *fb, int width, int height, GLenum target)
+{
     GLuint texture;
 
     glGenTextures(1, &texture);
-    glBindTexture(GL_TEXTURE_2D, texture);
-    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,
+    glBindTexture(target, texture);
+    glTexImage2D(target, 0, GL_RGBA, width, height,
                  0, GL_BGRA, GL_UNSIGNED_BYTE, 0);
 
-    egl_fb_setup_for_tex(fb, width, height, texture, true);
+    egl_fb_setup_for_tex_target(fb, width, height, texture, target, true);
 }
 
+void egl_fb_setup_new_tex(egl_fb *fb, int width, int height)
+{
+    egl_fb_setup_new_tex_target(fb, width, height, GL_TEXTURE_2D);
+}
+
 void egl_fb_blit(egl_fb *dst, egl_fb *src, bool flip)
 {
     GLuint x1 = 0;
@@ -127,17 +139,17 @@
                  GL_BGRA, GL_UNSIGNED_BYTE, surface_data(dst));
 }
 
-void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip)
+void egl_texture_blit(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip, bool swap)
 {
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
     glViewport(0, 0, dst->width, dst->height);
     glEnable(GL_TEXTURE_2D);
-    glBindTexture(GL_TEXTURE_2D, src->texture);
-    qemu_gl_run_texture_blit(gls, flip);
+    glBindTexture(src->texture_target, src->texture);
+    qemu_gl_run_texture_blit(gls, flip, swap);
 }
 
 void egl_texture_blend(QemuGLShader *gls, egl_fb *dst, egl_fb *src, bool flip,
-                       int x, int y, double scale_x, double scale_y)
+                       bool swap, int x, int y, double scale_x, double scale_y)
 {
     glBindFramebuffer(GL_FRAMEBUFFER_EXT, dst->framebuffer);
     int w = scale_x * src->width;
@@ -148,10 +160,10 @@
         glViewport(x, dst->height - h - y, w, h);
     }
     glEnable(GL_TEXTURE_2D);
-    glBindTexture(GL_TEXTURE_2D, src->texture);
+    glBindTexture(src->texture_target, src->texture);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    qemu_gl_run_texture_blit(gls, flip);
+    qemu_gl_run_texture_blit(gls, flip, swap);
     glDisable(GL_BLEND);
 }
 
@@ -334,7 +346,7 @@
 
 /* ---------------------------------------------------------------------- */
 
-EGLSurface qemu_egl_init_surface_x11(EGLContext ectx, EGLNativeWindowType win)
+EGLSurface qemu_egl_init_surface(EGLContext ectx, EGLNativeWindowType win)
 {
     EGLSurface esurface;
     EGLBoolean b;
@@ -356,63 +368,42 @@
     return esurface;
 }
 
-/* ---------------------------------------------------------------------- */
-
-#if defined(CONFIG_X11) || defined(CONFIG_GBM)
-
-/*
- * Taken from glamor_egl.h from the Xorg xserver, which is MIT licensed
- *
- * Create an EGLDisplay from a native display type. This is a little quirky
- * for a few reasons.
- *
- * 1: GetPlatformDisplayEXT and GetPlatformDisplay are the API you want to
- * use, but have different function signatures in the third argument; this
- * happens not to matter for us, at the moment, but it means epoxy won't alias
- * them together.
- *
- * 2: epoxy 1.3 and earlier don't understand EGL client extensions, which
- * means you can't call "eglGetPlatformDisplayEXT" directly, as the resolver
- * will crash.
- *
- * 3: You can't tell whether you have EGL 1.5 at this point, because
- * eglQueryString(EGL_VERSION) is a property of the display, which we don't
- * have yet. So you have to query for extensions no matter what. Fortunately
- * epoxy_has_egl_extension _does_ let you query for client extensions, so
- * we don't have to write our own extension string parsing.
- *
- * 4. There is no EGL_KHR_platform_base to complement the EXT one, thus one
- * needs to know EGL 1.5 is supported in order to use the eglGetPlatformDisplay
- * function pointer.
- * We can workaround this (circular dependency) by probing for the EGL 1.5
- * platform extensions (EGL_KHR_platform_gbm and friends) yet it doesn't seem
- * like mesa will be able to advertise these (even though it can do EGL 1.5).
- */
-static EGLDisplay qemu_egl_get_display(EGLNativeDisplayType native,
-                                       EGLenum platform)
+EGLSurface qemu_egl_init_buffer_surface(EGLContext ectx,
+                                        EGLenum buftype,
+                                        EGLClientBuffer buffer,
+                                        const EGLint *attrib_list)
 {
-    EGLDisplay dpy = EGL_NO_DISPLAY;
+    EGLSurface esurface;
+    EGLBoolean b;
 
-    /* In practise any EGL 1.5 implementation would support the EXT extension */
-    if (epoxy_has_egl_extension(NULL, "EGL_EXT_platform_base")) {
-        PFNEGLGETPLATFORMDISPLAYEXTPROC getPlatformDisplayEXT =
-            (void *) eglGetProcAddress("eglGetPlatformDisplayEXT");
-        if (getPlatformDisplayEXT && platform != 0) {
-            dpy = getPlatformDisplayEXT(platform, native, NULL);
-        }
+    esurface = eglCreatePbufferFromClientBuffer(qemu_egl_display,
+                                                buftype,
+                                                buffer,
+                                                qemu_egl_config,
+                                                attrib_list);
+    if (esurface == EGL_NO_SURFACE) {
+        error_report("egl: eglCreatePbufferFromClientBuffer failed");
+        return NULL;
     }
 
-    if (dpy == EGL_NO_DISPLAY) {
-        /* fallback */
-        dpy = eglGetDisplay(native);
+    b = eglMakeCurrent(qemu_egl_display, esurface, esurface, ectx);
+    if (b == EGL_FALSE) {
+        error_report("egl: eglMakeCurrent failed");
+        return NULL;
     }
-    return dpy;
+
+    return esurface;
 }
 
-static int qemu_egl_init_dpy(EGLNativeDisplayType dpy,
-                             EGLenum platform,
-                             DisplayGLMode mode)
+bool qemu_egl_destroy_surface(EGLSurface surface)
 {
+    return eglDestroySurface(qemu_egl_display, surface);
+}
+
+/* ---------------------------------------------------------------------- */
+
+static int qemu_egl_init_dpy(EGLDisplay dpy, DisplayGLMode mode)
+{
     static const EGLint conf_att_core[] = {
         EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
         EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT,
@@ -436,11 +427,7 @@
     EGLint n;
     bool gles = (mode == DISPLAYGL_MODE_ES);
 
-    qemu_egl_display = qemu_egl_get_display(dpy, platform);
-    if (qemu_egl_display == EGL_NO_DISPLAY) {
-        error_report("egl: eglGetDisplay failed");
-        return -1;
-    }
+    qemu_egl_display = dpy;
 
     b = eglInitialize(qemu_egl_display, &major, &minor);
     if (b == EGL_FALSE) {
@@ -468,22 +455,107 @@
     return 0;
 }
 
+int qemu_egl_init_dpy_cocoa(DisplayGLMode mode)
+{
+    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetDisplay failed");
+        return -1;
+    }
+
+    return qemu_egl_init_dpy(dpy, mode);
+}
+
+/*
+ * Taken from glamor_egl.h from the Xorg xserver, which is MIT licensed
+ *
+ * Create an EGLDisplay from a native display type. This is a little quirky
+ * for a few reasons.
+ *
+ * 1: GetPlatformDisplayEXT and GetPlatformDisplay are the API you want to
+ * use, but have different function signatures in the third argument; this
+ * happens not to matter for us, at the moment, but it means epoxy won't alias
+ * them together.
+ *
+ * 2: epoxy 1.3 and earlier don't understand EGL client extensions, which
+ * means you can't call "eglGetPlatformDisplayEXT" directly, as the resolver
+ * will crash.
+ *
+ * 3: You can't tell whether you have EGL 1.5 at this point, because
+ * eglQueryString(EGL_VERSION) is a property of the display, which we don't
+ * have yet. So you have to query for extensions no matter what. Fortunately
+ * epoxy_has_egl_extension _does_ let you query for client extensions, so
+ * we don't have to write our own extension string parsing.
+ *
+ * 4. There is no EGL_KHR_platform_base to complement the EXT one, thus one
+ * needs to know EGL 1.5 is supported in order to use the eglGetPlatformDisplay
+ * function pointer.
+ * We can workaround this (circular dependency) by probing for the EGL 1.5
+ * platform extensions (EGL_KHR_platform_gbm and friends) yet it doesn't seem
+ * like mesa will be able to advertise these (even though it can do EGL 1.5).
+ */
+static int qemu_egl_init_dpy_platform(EGLNativeDisplayType native,
+                                      EGLenum platform,
+                                      DisplayGLMode mode)
+{
+    EGLDisplay dpy = EGL_NO_DISPLAY;
+
+    /* In practise any EGL 1.5 implementation would support the EXT extension */
+    if (epoxy_has_egl_extension(NULL, "EGL_EXT_platform_base")) {
+        PFNEGLGETPLATFORMDISPLAYEXTPROC getPlatformDisplayEXT =
+            (void *) eglGetProcAddress("eglGetPlatformDisplayEXT");
+        if (getPlatformDisplayEXT && platform != 0) {
+            dpy = getPlatformDisplayEXT(platform, native, NULL);
+        }
+    }
+
+#if defined(CONFIG_X11) || defined(CONFIG_GBM)
+    if (dpy == EGL_NO_DISPLAY) {
+        /* fallback */
+        dpy = eglGetDisplay(native);
+    }
+#endif
+
+    if (dpy == EGL_NO_DISPLAY) {
+        error_report("egl: eglGetDisplay failed");
+        return -1;
+    }
+
+    return qemu_egl_init_dpy(dpy, mode);
+}
+
+int qemu_egl_init_dpy_surfaceless(DisplayGLMode mode)
+{
+    return qemu_egl_init_dpy_platform(NULL, EGL_PLATFORM_SURFACELESS_MESA, mode);
+}
+
+#if defined(CONFIG_X11) || defined(CONFIG_GBM)
+
 int qemu_egl_init_dpy_x11(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_KHR_platform_x11
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_X11_KHR, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_X11_KHR, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
 }
 
 int qemu_egl_init_dpy_mesa(EGLNativeDisplayType dpy, DisplayGLMode mode)
 {
 #ifdef EGL_MESA_platform_gbm
-    return qemu_egl_init_dpy(dpy, EGL_PLATFORM_GBM_MESA, mode);
+    return qemu_egl_init_dpy_platform(dpy, EGL_PLATFORM_GBM_MESA, mode);
 #else
-    return qemu_egl_init_dpy(dpy, 0, mode);
+    return qemu_egl_init_dpy_platform(dpy, 0, mode);
 #endif
+}
+
+#endif
+
+#if defined(CONFIG_ANGLE)
+
+int qemu_egl_init_dpy_angle(DisplayGLMode mode)
+{
+    return qemu_egl_init_dpy_platform(NULL, EGL_PLATFORM_ANGLE_ANGLE, mode);
 }
 
 #endif
diff -ru --un qemu-7.2.0/ui/gtk-egl.c qemu-utm-7.2.0/ui/gtk-egl.c
--- qemu-7.2.0/ui/gtk-egl.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/gtk-egl.c	2022-12-26 13:45:04
@@ -54,7 +54,7 @@
     }
 
     vc->gfx.ectx = qemu_egl_init_ctx();
-    vc->gfx.esurface = qemu_egl_init_surface_x11
+    vc->gfx.esurface = qemu_egl_init_surface
         (vc->gfx.ectx, (EGLNativeWindowType)x11_window);
 
     assert(vc->gfx.esurface);
@@ -219,14 +219,14 @@
     gtk_egl_set_scanout_mode(vc, false);
 }
 
-void gd_egl_scanout_texture(DisplayChangeListener *dcl,
-                            uint32_t backing_id, bool backing_y_0_top,
-                            uint32_t backing_width, uint32_t backing_height,
-                            uint32_t x, uint32_t y,
-                            uint32_t w, uint32_t h)
+static void gd_egl_scanout_borrowed_texture(VirtualConsole *vc,
+                                            uint32_t backing_id,
+                                            bool backing_y_0_top,
+                                            uint32_t backing_width,
+                                            uint32_t backing_height,
+                                            uint32_t x, uint32_t y,
+                                            uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -241,9 +241,25 @@
                          backing_id, false);
 }
 
-void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl,
-                           QemuDmaBuf *dmabuf)
+void gd_egl_scanout_texture(DisplayChangeListener *dcl, uint32_t backing_id,
+                            DisplayGLTextureBorrower backing_borrow,
+                            uint32_t x, uint32_t y,
+                            uint32_t w, uint32_t h)
 {
+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    gd_egl_scanout_borrowed_texture(vc, backing_texture, backing_y_0_top,
+                                    backing_width, backing_height,
+                                    x, y, w, h);
+}
+
+void gd_egl_scanout_dmabuf(DisplayChangeListener *dcl, QemuDmaBuf *dmabuf)
+{
 #ifdef CONFIG_GBM
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
 
@@ -255,9 +271,9 @@
         return;
     }
 
-    gd_egl_scanout_texture(dcl, dmabuf->texture,
-                           false, dmabuf->width, dmabuf->height,
-                           0, 0, dmabuf->width, dmabuf->height);
+    gd_egl_scanout_borrowed_texture(vc, dmabuf->texture,
+                                    false, dmabuf->width, dmabuf->height,
+                                    0, 0, dmabuf->width, dmabuf->height);
 
     if (dmabuf->allow_fences) {
         vc->gfx.guest_fb.dmabuf = dmabuf;
@@ -317,9 +333,9 @@
     egl_fb_setup_default(&vc->gfx.win_fb, ww, wh);
     if (vc->gfx.cursor_fb.texture) {
         egl_texture_blit(vc->gfx.gls, &vc->gfx.win_fb, &vc->gfx.guest_fb,
-                         vc->gfx.y0_top);
+                         vc->gfx.y0_top, false);
         egl_texture_blend(vc->gfx.gls, &vc->gfx.win_fb, &vc->gfx.cursor_fb,
-                          vc->gfx.y0_top,
+                          vc->gfx.y0_top, false,
                           vc->gfx.cursor_x, vc->gfx.cursor_y,
                           vc->gfx.scale_x, vc->gfx.scale_y);
     } else {
diff -ru --un qemu-7.2.0/ui/gtk-gl-area.c qemu-utm-7.2.0/ui/gtk-gl-area.c
--- qemu-7.2.0/ui/gtk-gl-area.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/gtk-gl-area.c	2022-12-26 13:45:04
@@ -121,7 +121,12 @@
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
 
+<<<<<<< HEAD
+    gd_update_monitor_refresh_rate(
+            vc, vc->window ? vc->window : vc->gfx.drawing_area);
+=======
     gd_update_monitor_refresh_rate(vc, vc->window ? vc->window : vc->gfx.drawing_area);
+>>>>>>> v7.1.0
 
     if (!vc->gfx.gls) {
         if (!gtk_widget_get_realized(vc->gfx.drawing_area)) {
@@ -238,16 +243,14 @@
     g_clear_object(&ctx);
 }
 
-void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
-                                uint32_t backing_id,
-                                bool backing_y_0_top,
-                                uint32_t backing_width,
-                                uint32_t backing_height,
-                                uint32_t x, uint32_t y,
-                                uint32_t w, uint32_t h)
+static void gd_gl_area_scanout_borrowed_texture(VirtualConsole *vc,
+                                                uint32_t backing_id,
+                                                bool backing_y_0_top,
+                                                uint32_t backing_width,
+                                                uint32_t backing_height,
+                                                uint32_t x, uint32_t y,
+                                                uint32_t w, uint32_t h)
 {
-    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
-
     vc->gfx.x = x;
     vc->gfx.y = y;
     vc->gfx.w = w;
@@ -256,7 +259,7 @@
 
     gtk_gl_area_make_current(GTK_GL_AREA(vc->gfx.drawing_area));
 
-    if (backing_id == 0 || vc->gfx.w == 0 || vc->gfx.h == 0) {
+    if (vc->gfx.w == 0 || vc->gfx.h == 0) {
         gtk_gl_area_set_scanout_mode(vc, false);
         return;
     }
@@ -266,6 +269,25 @@
                          backing_id, false);
 }
 
+void gd_gl_area_scanout_texture(DisplayChangeListener *dcl,
+                                uint32_t backing_id,
+                                DisplayGLTextureBorrower backing_borrow,
+                                uint32_t x, uint32_t y,
+                                uint32_t w, uint32_t h)
+{
+    VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+    gd_gl_area_scanout_borrowed_texture(vc, backing_texture,
+                                        backing_y_0_top,
+                                        backing_width, backing_height,
+                                        x, y, w, h);
+}
+
 void gd_gl_area_scanout_disable(DisplayChangeListener *dcl)
 {
     VirtualConsole *vc = container_of(dcl, VirtualConsole, gfx.dcl);
@@ -297,9 +319,9 @@
         return;
     }
 
-    gd_gl_area_scanout_texture(dcl, dmabuf->texture,
-                               false, dmabuf->width, dmabuf->height,
-                               0, 0, dmabuf->width, dmabuf->height);
+    gd_gl_area_scanout_borrowed_texture(vc, dmabuf->texture,
+                                        false, dmabuf->width, dmabuf->height,
+                                        0, 0, dmabuf->width, dmabuf->height);
 
     if (dmabuf->allow_fences) {
         vc->gfx.guest_fb.dmabuf = dmabuf;
diff -ru --un qemu-7.2.0/ui/gtk.c qemu-utm-7.2.0/ui/gtk.c
--- qemu-7.2.0/ui/gtk.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/gtk.c	2022-12-26 13:45:04
@@ -663,7 +663,7 @@
 };
 #endif
 
-#endif /* CONFIG_OPENGL */
+#endif /* defined(CONFIG_OPENGL) */
 
 /** QEMU Events **/
 
@@ -2472,6 +2472,6 @@
 
 type_init(register_gtk);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
 module_dep("ui-opengl");
 #endif
diff -ru --un qemu-7.2.0/ui/meson.build qemu-utm-7.2.0/ui/meson.build
--- qemu-7.2.0/ui/meson.build	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/meson.build	2022-12-26 13:45:04
@@ -63,9 +65,9 @@
   ui_modules += {'opengl' : opengl_ss}
 endif
 
-if opengl.found() and gbm.found()
+if opengl.found()
   egl_headless_ss = ss.source_set()
-  egl_headless_ss.add(when: [opengl, gbm, pixman],
+  egl_headless_ss.add(when: [opengl, pixman],
                       if_true: files('egl-headless.c'))
   ui_modules += {'egl-headless' : egl_headless_ss}
 endif
@@ -128,6 +130,9 @@
     'spice-input.c',
     'spice-display.c'
   ))
+  if iosurface.found()
+    spice_core_ss.add(iosurface)
+  endif
   ui_modules += {'spice-core' : spice_core_ss}
 endif
 
diff -ru --un qemu-7.2.0/ui/sdl2-gl.c qemu-utm-7.2.0/ui/sdl2-gl.c
--- qemu-7.2.0/ui/sdl2-gl.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/sdl2-gl.c	2022-12-26 13:45:04
@@ -197,15 +197,20 @@
 
 void sdl2_gl_scanout_texture(DisplayChangeListener *dcl,
                              uint32_t backing_id,
-                             bool backing_y_0_top,
-                             uint32_t backing_width,
-                             uint32_t backing_height,
+                             DisplayGLTextureBorrower backing_borrow,
                              uint32_t x, uint32_t y,
                              uint32_t w, uint32_t h)
 {
     struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
+    bool backing_y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
 
     assert(scon->opengl);
+
+    GLuint backing_texture = backing_borrow(backing_id, &backing_y_0_top,
+                                            &backing_width, &backing_height);
+
     scon->x = x;
     scon->y = y;
     scon->w = w;
@@ -216,7 +221,7 @@
 
     sdl2_set_scanout_mode(scon, true);
     egl_fb_setup_for_tex(&scon->guest_fb, backing_width, backing_height,
-                         backing_id, false);
+                         backing_texture, false);
 }
 
 void sdl2_gl_scanout_flush(DisplayChangeListener *dcl,
diff -ru --un qemu-7.2.0/ui/sdl2.c qemu-utm-7.2.0/ui/sdl2.c
--- qemu-7.2.0/ui/sdl2.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/sdl2.c	2022-12-26 13:45:04
@@ -88,7 +88,7 @@
     if (scon->hidden) {
         flags |= SDL_WINDOW_HIDDEN;
     }
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
     if (scon->opengl) {
         flags |= SDL_WINDOW_OPENGL;
     }
@@ -132,7 +132,7 @@
 static void sdl2_redraw(struct sdl2_console *scon)
 {
     if (scon->opengl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
         sdl2_gl_redraw(scon);
 #endif
     } else {
@@ -775,7 +775,7 @@
     .dpy_cursor_define    = sdl_mouse_define,
 };
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
 static const DisplayChangeListenerOps dcl_gl_ops = {
     .dpy_name                = "sdl2-gl",
     .dpy_gfx_update          = sdl2_gl_update,
@@ -809,7 +809,7 @@
 {
     assert(o->type == DISPLAY_TYPE_SDL);
     if (o->has_gl && o->gl) {
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
         display_opengl = 1;
 #endif
     }
@@ -883,7 +883,7 @@
         }
         sdl2_console[i].idx = i;
         sdl2_console[i].opts = o;
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
         sdl2_console[i].opengl = display_opengl;
         sdl2_console[i].dcl.ops = display_opengl ? &dcl_gl_ops : &dcl_2d_ops;
         sdl2_console[i].dgc.ops = display_opengl ? &gl_ctx_ops : NULL;
@@ -952,6 +952,6 @@
 
 type_init(register_sdl1);
 
-#ifdef CONFIG_OPENGL
+#if defined(CONFIG_OPENGL)
 module_dep("ui-opengl");
 #endif
diff -ru --un qemu-7.2.0/ui/shader/meson.build qemu-utm-7.2.0/ui/shader/meson.build
--- qemu-7.2.0/ui/shader/meson.build	2022-12-14 11:28:44
+++ qemu-utm-7.2.0/ui/shader/meson.build	2022-12-26 13:45:04
@@ -1,5 +1,6 @@
 shaders = [
   ['texture-blit', 'frag'],
+  ['texture-blit-swap', 'frag'],
   ['texture-blit', 'vert'],
   ['texture-blit-flip', 'vert'],
 ]
diff -ru --un qemu-7.2.0/ui/shader/texture-blit-flip.vert qemu-utm-7.2.0/ui/shader/texture-blit-flip.vert
--- qemu-7.2.0/ui/shader/texture-blit-flip.vert	2022-12-14 11:28:44
+++ qemu-utm-7.2.0/ui/shader/texture-blit-flip.vert	2022-12-26 13:45:04
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 
diff -ru --un qemu-7.2.0/ui/shader/texture-blit-swap.frag qemu-utm-7.2.0/ui/shader/texture-blit-swap.frag
--- qemu-7.2.0/ui/shader/texture-blit-swap.frag	1969-12-31 19:00:00
+++ qemu-utm-7.2.0/ui/shader/texture-blit-swap.frag	2022-12-26 13:45:04
@@ -0,0 +1,7 @@
+uniform sampler2D image;
+in  mediump vec2 ex_tex_coord;
+out mediump vec4 out_frag_color;
+
+void main(void) {
+     out_frag_color = texture(image, ex_tex_coord).zyxw;
+}
diff -ru --un qemu-7.2.0/ui/shader/texture-blit.frag qemu-utm-7.2.0/ui/shader/texture-blit.frag
--- qemu-7.2.0/ui/shader/texture-blit.frag	2022-12-14 11:28:44
+++ qemu-utm-7.2.0/ui/shader/texture-blit.frag	2022-12-26 13:45:04
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 uniform sampler2D image;
 in  mediump vec2 ex_tex_coord;
 out mediump vec4 out_frag_color;
diff -ru --un qemu-7.2.0/ui/shader/texture-blit.vert qemu-utm-7.2.0/ui/shader/texture-blit.vert
--- qemu-7.2.0/ui/shader/texture-blit.vert	2022-12-14 11:28:44
+++ qemu-utm-7.2.0/ui/shader/texture-blit.vert	2022-12-26 13:45:04
@@ -1,6 +1,3 @@
-
-#version 300 es
-
 in vec2  in_position;
 out vec2 ex_tex_coord;
 
diff -ru --un qemu-7.2.0/ui/shader.c qemu-utm-7.2.0/ui/shader.c
--- qemu-7.2.0/ui/shader.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/shader.c	2022-12-26 13:45:04
@@ -30,10 +30,13 @@
 #include "ui/shader/texture-blit-vert.h"
 #include "ui/shader/texture-blit-flip-vert.h"
 #include "ui/shader/texture-blit-frag.h"
+#include "ui/shader/texture-blit-swap-frag.h"
 
 struct QemuGLShader {
     GLint texture_blit_prog;
     GLint texture_blit_flip_prog;
+    GLint texture_blit_swap_prog;
+    GLint texture_blit_flip_swap_prog;
     GLint texture_blit_vao;
 };
 
@@ -69,11 +72,17 @@
     return vao;
 }
 
-void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip)
+void qemu_gl_run_texture_blit(QemuGLShader *gls, bool flip, bool swapped)
 {
-    glUseProgram(flip
-                 ? gls->texture_blit_flip_prog
-                 : gls->texture_blit_prog);
+    if (flip && swapped) {
+        glUseProgram(gls->texture_blit_flip_swap_prog);
+    } else if (flip && !swapped) {
+        glUseProgram(gls->texture_blit_flip_prog);
+    } else if (!flip && swapped) {
+        glUseProgram(gls->texture_blit_swap_prog);
+    } else { // !flip && !swapped
+        glUseProgram(gls->texture_blit_prog);
+    }
     glBindVertexArray(gls->texture_blit_vao);
     glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
 }
@@ -152,12 +161,27 @@
 QemuGLShader *qemu_gl_init_shader(void)
 {
     QemuGLShader *gls = g_new0(QemuGLShader, 1);
+    const char *header = epoxy_is_desktop_gl() ? "#version 140\n" : "#version 300 es\n";
+    char vert_src[256];
+    char frag_src[256];
+    char *vert_src_body = stpcpy(vert_src, header);
+    char *frag_src_body = stpcpy(frag_src, header);
 
+    strcpy(vert_src_body, texture_blit_vert_src);
+    strcpy(frag_src_body, texture_blit_frag_src);
     gls->texture_blit_prog = qemu_gl_create_compile_link_program
-        (texture_blit_vert_src, texture_blit_frag_src);
+        (vert_src, frag_src);
+    strcpy(vert_src_body, texture_blit_flip_vert_src);
     gls->texture_blit_flip_prog = qemu_gl_create_compile_link_program
-        (texture_blit_flip_vert_src, texture_blit_frag_src);
-    if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog) {
+        (vert_src, frag_src);
+    strcpy(frag_src_body, texture_blit_swap_frag_src);
+    gls->texture_blit_flip_swap_prog = qemu_gl_create_compile_link_program
+        (vert_src, frag_src);
+    strcpy(vert_src_body, texture_blit_vert_src);
+    gls->texture_blit_swap_prog = qemu_gl_create_compile_link_program
+        (vert_src, frag_src);
+    if (!gls->texture_blit_prog || !gls->texture_blit_flip_prog ||
+        !gls->texture_blit_swap_prog || !gls->texture_blit_flip_swap_prog) {
         exit(1);
     }
 
diff -ru --un qemu-7.2.0/ui/spice-core.c qemu-utm-7.2.0/ui/spice-core.c
--- qemu-7.2.0/ui/spice-core.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/spice-core.c	2022-12-26 13:45:04
@@ -52,6 +52,10 @@
 
 static QemuThread me;
 
+#ifdef CONFIG_ANGLE
+extern EGLContext spice_gl_ctx;
+#endif
+
 struct SpiceTimer {
     QEMUTimer *timer;
 };
@@ -840,11 +844,27 @@
                          "incompatible with -spice port/tls-port");
             exit(1);
         }
+#if defined(CONFIG_GBM)
         if (egl_rendernode_init(qemu_opt_get(opts, "rendernode"),
                                 DISPLAYGL_MODE_ON) != 0) {
             error_report("Failed to initialize EGL render node for SPICE GL");
             exit(1);
         }
+#elif defined(CONFIG_ANGLE)
+        if (qemu_egl_init_dpy_angle(DISPLAYGL_MODE_ES)) {
+            error_report("SPICE GL failed to initialize ANGLE display");
+            exit(1);
+        }
+
+        spice_gl_ctx = qemu_egl_init_ctx();
+        if (!spice_gl_ctx) {
+            error_report("egl: egl_init_ctx failed");
+            exit(1);
+        }
+#else
+        error_report("No backend to support SPICE GL");
+        exit(1);
+#endif
         display_opengl = 1;
         spice_opengl = 1;
     }
diff -ru --un qemu-7.2.0/ui/spice-display.c qemu-utm-7.2.0/ui/spice-display.c
--- qemu-7.2.0/ui/spice-display.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/spice-display.c	2022-12-26 13:45:48
@@ -24,11 +24,22 @@
 #include "qemu/queue.h"
 #include "ui/console.h"
 #include "trace.h"
+#ifdef CONFIG_IOSURFACE
+#include <TargetConditionals.h>
+#endif
+#ifdef CONFIG_ANGLE
+#include <GLES2/gl2.h>
+#include <GLES2/gl2ext.h>
+#endif
 
 #include "ui/spice-display.h"
 
 bool spice_opengl;
 
+#ifdef CONFIG_ANGLE
+EGLContext spice_gl_ctx;
+#endif
+
 int qemu_spice_rect_is_empty(const QXLRect* r)
 {
     return r->top == r->bottom || r->left == r->right;
@@ -799,6 +810,178 @@
 
 #ifdef HAVE_SPICE_GL
 
+#if defined(CONFIG_IOSURFACE)
+
+static void AddIntegerValue(CFMutableDictionaryRef dictionary, const CFStringRef key, int32_t value)
+{
+    CFNumberRef number = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &value);
+    CFDictionaryAddValue(dictionary, key, number);
+    CFRelease(number);
+}
+
+static int spice_iosurface_create(SimpleSpiceDisplay *ssd, int width, int height)
+{
+    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(
+        kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+    AddIntegerValue(dict, kIOSurfaceWidth, width);
+    AddIntegerValue(dict, kIOSurfaceHeight, height);
+    AddIntegerValue(dict, kIOSurfacePixelFormat, 'BGRA');
+    AddIntegerValue(dict, kIOSurfaceBytesPerElement, 4);
+#if TARGET_OS_OSX
+    CFDictionaryAddValue(dict, kIOSurfaceIsGlobal, kCFBooleanTrue);
+#endif
+
+    ssd->iosurface = IOSurfaceCreate(dict);
+    CFRelease(dict);
+
+    if (!ssd->iosurface) {
+        error_report("spice_iosurface_create: IOSurfaceCreate failed");
+        return 0;
+    }
+
+#if defined(CONFIG_ANGLE)
+    EGLint target = 0;
+    GLenum tex_target = 0;
+    if (eglGetConfigAttrib(qemu_egl_display,
+                           qemu_egl_config,
+                           EGL_BIND_TO_TEXTURE_TARGET_ANGLE,
+                           &target) != EGL_TRUE) {
+        error_report("spice_iosurface_create: eglGetConfigAttrib failed");
+        return 0;
+    }
+    if (target == EGL_TEXTURE_2D) {
+        tex_target = GL_TEXTURE_2D;
+    } else if (target == EGL_TEXTURE_RECTANGLE_ANGLE) {
+        tex_target = GL_TEXTURE_RECTANGLE_ANGLE;
+    } else {
+        error_report("spice_iosurface_create: unsupported texture target");
+        return 0;
+    }
+
+    const EGLint attribs[] = {
+        EGL_WIDTH,                         width,
+        EGL_HEIGHT,                        height,
+        EGL_IOSURFACE_PLANE_ANGLE,         0,
+        EGL_TEXTURE_TARGET,                target,
+        EGL_TEXTURE_INTERNAL_FORMAT_ANGLE, GL_BGRA_EXT,
+        EGL_TEXTURE_FORMAT,                EGL_TEXTURE_RGBA,
+        EGL_TEXTURE_TYPE_ANGLE,            GL_UNSIGNED_BYTE,
+        EGL_IOSURFACE_USAGE_HINT_ANGLE,    EGL_IOSURFACE_WRITE_HINT_ANGLE,
+        EGL_NONE,                          EGL_NONE,
+    };
+    ssd->esurface = qemu_egl_init_buffer_surface(spice_gl_ctx,
+                                                 EGL_IOSURFACE_ANGLE,
+                                                 ssd->iosurface,
+                                                 attribs);
+
+    if (ssd->esurface == NULL) {
+        goto gl_error;
+    }
+
+    egl_fb_setup_new_tex_target(&ssd->iosurface_fb, width, height, tex_target);
+
+    return 1;
+gl_error:
+    CFRelease(ssd->iosurface);
+    ssd->iosurface = NULL;
+    return 0;
+#else
+    error_report("spice_iosurface_create: ANGLE not found");
+    return 0;
+#endif
+}
+
+static void spice_iosurface_destroy(SimpleSpiceDisplay *ssd)
+{
+    if (!ssd->iosurface) {
+        return;
+    }
+#if defined(CONFIG_ANGLE)
+    egl_fb_destroy(&ssd->iosurface_fb);
+    qemu_egl_destroy_surface(ssd->esurface);
+    ssd->esurface = EGL_NO_SURFACE;
+#endif
+    if (ssd->surface_send_fd > -1) {
+        // this sends POLLHUP and indicates that any unread data is stale
+        // and should not be used
+        close(ssd->surface_send_fd);
+        ssd->surface_send_fd = -1;
+    }
+    // FIXME: still a tiny race with the close() above
+    CFRelease(ssd->iosurface);
+    ssd->iosurface = NULL;
+}
+
+static int spice_iosurface_resize(SimpleSpiceDisplay *ssd, int width, int height)
+{
+    if (ssd->iosurface) {
+        if (IOSurfaceGetHeight(ssd->iosurface) != width ||
+            IOSurfaceGetWidth(ssd->iosurface) != height) {
+            spice_iosurface_destroy(ssd);
+            return spice_iosurface_create(ssd, width, height);
+        } else {
+            return 1;
+        }
+    } else {
+        return spice_iosurface_create(ssd, width, height);
+    }
+}
+
+/* FIXME: use mach ports instead of this hack */
+static int spice_iosurface_create_fd(SimpleSpiceDisplay *ssd, int *fourcc)
+{
+    int fds[2];
+    IOSurfaceID surfaceid;
+
+    if (!ssd->iosurface) {
+        return -1;
+    }
+    if (pipe(fds) < 0) {
+        error_report("spice_iosurface_create_fd: failed to create pipe");
+        return -1;
+    }
+    if (ssd->surface_send_fd > -1) {
+        close(ssd->surface_send_fd);
+    }
+    // we keep the write end of the pipe open for the lifetime of this surface
+    // when we close it, POLLHUP will be seen by the other side and know that
+    // the surface ID is stale and should not be used
+    ssd->surface_send_fd = fds[1];
+    *fourcc = 'BGRA';
+    surfaceid = IOSurfaceGetID(ssd->iosurface);
+    write(ssd->surface_send_fd, &surfaceid, sizeof(surfaceid));
+    return fds[0];
+}
+
+static void spice_iosurface_blit(SimpleSpiceDisplay *ssd, GLuint src_texture, bool flip, bool swap)
+{
+    egl_fb tmp_fb = { .texture = src_texture, .texture_target = GL_TEXTURE_2D };
+    if (!ssd->iosurface) {
+        return;
+    }
+
+#if defined(CONFIG_ANGLE)
+    eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
+    glBindTexture(ssd->iosurface_fb.texture_target, ssd->iosurface_fb.texture);
+    eglBindTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
+    egl_texture_blit(ssd->gls, &ssd->iosurface_fb, &tmp_fb, flip, swap);
+#endif
+}
+
+static void spice_iosurface_flush(SimpleSpiceDisplay *ssd)
+{
+    if (!ssd->iosurface) {
+        return;
+    }
+
+#if defined(CONFIG_ANGLE)
+    eglMakeCurrent(qemu_egl_display, ssd->esurface, ssd->esurface, spice_gl_ctx);
+    eglReleaseTexImage(qemu_egl_display, ssd->esurface, EGL_BACK_BUFFER);
+#endif
+}
+
+#endif
+
 static void qemu_spice_gl_monitor_config(SimpleSpiceDisplay *ssd,
                                          int x, int y, int w, int h)
 {
@@ -860,6 +1043,9 @@
     graphic_hw_update(dcl->con);
     if (ssd->gl_updates && ssd->have_surface) {
         qemu_spice_gl_block(ssd, true);
+#if defined(CONFIG_IOSURFACE)
+        spice_iosurface_flush(ssd);
+#endif
         glFlush();
         cookie = (uintptr_t)qxl_cookie_new(QXL_COOKIE_TYPE_GL_DRAW_DONE, 0);
         spice_qxl_gl_draw_async(&ssd->qxl, 0, 0,
@@ -876,6 +1062,11 @@
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
 
     surface_gl_update_texture(ssd->gls, ssd->ds, x, y, w, h);
+#if defined(CONFIG_IOSURFACE)
+    if (!qemu_console_is_gl_blocked(ssd->dcl.con)) {
+        spice_iosurface_blit(ssd, ssd->ds->texture, true, ssd->ds->glswapped);
+    }
+#endif
     ssd->gl_updates++;
 }
 
@@ -883,15 +1074,23 @@
                             struct DisplaySurface *new_surface)
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
-    EGLint stride, fourcc;
-    int fd;
+    EGLint stride = 0, fourcc = 0;
+    int fd = -1;
+    int width = 0, height = 0;
 
     if (ssd->ds) {
+#if defined(CONFIG_IOSURFACE)
+        // need to release texture from surface before destorying it
+        spice_iosurface_flush(ssd);
+#endif
         surface_gl_destroy_texture(ssd->gls, ssd->ds);
     }
     ssd->ds = new_surface;
+    width = surface_width(new_surface);
+    height = surface_height(new_surface);
     if (ssd->ds) {
         surface_gl_create_texture(ssd->gls, ssd->ds);
+#if defined(CONFIG_GBM)
         fd = egl_get_fd_for_texture(ssd->ds->texture,
                                     &stride, &fourcc,
                                     NULL);
@@ -899,31 +1098,48 @@
             surface_gl_destroy_texture(ssd->gls, ssd->ds);
             return;
         }
+#elif defined(CONFIG_IOSURFACE)
+        if (spice_iosurface_resize(ssd, width, height)) {
+            fd = spice_iosurface_create_fd(ssd, &fourcc);
+            if (fd < 0) {
+                error_report("spice_gl_switch: failed to create fd");
+                return;
+            }
+        } else {
+            error_report("spice_gl_switch: failed to create IOSurface");
+            return;
+        }
+#endif
 
         trace_qemu_spice_gl_surface(ssd->qxl.id,
-                                    surface_width(ssd->ds),
-                                    surface_height(ssd->ds),
+                                    width,
+                                    height,
                                     fourcc);
 
         /* note: spice server will close the fd */
         spice_qxl_gl_scanout(&ssd->qxl, fd,
-                             surface_width(ssd->ds),
-                             surface_height(ssd->ds),
+                             width,
+                             height,
                              stride, fourcc, false);
         ssd->have_surface = true;
         ssd->have_scanout = false;
 
         qemu_spice_gl_monitor_config(ssd, 0, 0,
-                                     surface_width(ssd->ds),
-                                     surface_height(ssd->ds));
+                                     width,
+                                     height);
     }
 }
 
 static QEMUGLContext qemu_spice_gl_create_context(DisplayGLCtx *dgc,
                                                   QEMUGLParams *params)
 {
+#if defined(CONFIG_GBM)
     eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
                    qemu_egl_rn_ctx);
+#elif defined(CONFIG_ANGLE)
+    eglMakeCurrent(qemu_egl_display, EGL_NO_SURFACE, EGL_NO_SURFACE,
+                   spice_gl_ctx);
+#endif
     return qemu_egl_create_context(dgc, params);
 }
 
@@ -936,22 +1152,44 @@
     qemu_spice_gl_monitor_config(ssd, 0, 0, 0, 0);
     ssd->have_surface = false;
     ssd->have_scanout = false;
+#if defined(CONFIG_IOSURFACE)
+    spice_iosurface_destroy(ssd);
+#endif
+#if defined(CONFIG_ANGLE)
+    ssd->backing_borrow = NULL;
+    ssd->backing_id = -1;
+#endif
 }
 
 static void qemu_spice_gl_scanout_texture(DisplayChangeListener *dcl,
-                                          uint32_t tex_id,
-                                          bool y_0_top,
-                                          uint32_t backing_width,
-                                          uint32_t backing_height,
+                                          uint32_t backing_id,
+                                          DisplayGLTextureBorrower backing_borrow,
                                           uint32_t x, uint32_t y,
                                           uint32_t w, uint32_t h)
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
     EGLint stride = 0, fourcc = 0;
     int fd = -1;
+    bool y_0_top;
+    uint32_t backing_width;
+    uint32_t backing_height;
 
+    GLuint tex_id = backing_borrow(backing_id, &y_0_top,
+                                   &backing_width, &backing_height);
     assert(tex_id);
+#if defined(CONFIG_GBM)
     fd = egl_get_fd_for_texture(tex_id, &stride, &fourcc, NULL);
+#elif defined(CONFIG_IOSURFACE)
+    if (spice_iosurface_resize(ssd, backing_width, backing_height)) {
+#if defined(CONFIG_ANGLE)
+        ssd->backing_borrow = backing_borrow;
+        ssd->backing_id = backing_id;
+#endif
+        fd = spice_iosurface_create_fd(ssd, &fourcc);
+    } else {
+        fd = -1;
+    }
+#endif
     if (fd < 0) {
         fprintf(stderr, "%s: failed to get fd for texture\n", __func__);
         return;
@@ -966,6 +1204,7 @@
     ssd->have_scanout = true;
 }
 
+#ifdef CONFIG_GBM
 static void qemu_spice_gl_scanout_dmabuf(DisplayChangeListener *dcl,
                                          QemuDmaBuf *dmabuf)
 {
@@ -1023,21 +1262,25 @@
     }
     egl_dmabuf_release_texture(dmabuf);
 }
+#endif // CONFIG_GBM
 
 static void qemu_spice_gl_update(DisplayChangeListener *dcl,
                                  uint32_t x, uint32_t y, uint32_t w, uint32_t h)
 {
     SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);
+#ifdef CONFIG_GBM
     EGLint stride = 0, fourcc = 0;
+    int fd;
     bool render_cursor = false;
+#endif
     bool y_0_top = false; /* FIXME */
     uint64_t cookie;
-    int fd;
 
     if (!ssd->have_scanout) {
         return;
     }
 
+#ifdef CONFIG_GBM
     if (ssd->cursor_fb.texture) {
         render_cursor = true;
     }
@@ -1094,11 +1337,18 @@
         y = ssd->ptr_y;
         qemu_mutex_unlock(&ssd->lock);
         egl_texture_blit(ssd->gls, &ssd->blit_fb, &ssd->guest_fb,
-                         !y_0_top);
+                         !y_0_top, false);
         egl_texture_blend(ssd->gls, &ssd->blit_fb, &ssd->cursor_fb,
-                          !y_0_top, x, y, 1.0, 1.0);
+                          !y_0_top, false, x, y, 1.0, 1.0);
         glFlush();
     }
+#elif defined(CONFIG_ANGLE) && defined(CONFIG_IOSURFACE)
+    GLuint tex_id = ssd->backing_borrow(ssd->backing_id, &y_0_top,
+                                        NULL, NULL);
+    spice_iosurface_blit(ssd, tex_id, !y_0_top, false);
+    spice_iosurface_flush(ssd);
+    //TODO: cursor stuff
+#endif
 
     trace_qemu_spice_gl_update(ssd->qxl.id, w, h, x, y);
     qemu_spice_gl_block(ssd, true);
@@ -1118,10 +1368,12 @@
 
     .dpy_gl_scanout_disable  = qemu_spice_gl_scanout_disable,
     .dpy_gl_scanout_texture  = qemu_spice_gl_scanout_texture,
+#ifdef CONFIG_GBM
     .dpy_gl_scanout_dmabuf   = qemu_spice_gl_scanout_dmabuf,
     .dpy_gl_cursor_dmabuf    = qemu_spice_gl_cursor_dmabuf,
     .dpy_gl_cursor_position  = qemu_spice_gl_cursor_position,
     .dpy_gl_release_dmabuf   = qemu_spice_gl_release_dmabuf,
+#endif
     .dpy_gl_update           = qemu_spice_gl_update,
 };
 
@@ -1158,6 +1410,15 @@
         ssd->gls = qemu_gl_init_shader();
         ssd->have_surface = false;
         ssd->have_scanout = false;
+#if defined(CONFIG_IOSURFACE)
+        ssd->iosurface = NULL;
+        ssd->surface_send_fd = -1;
+#endif
+#if defined(CONFIG_ANGLE)
+        ssd->esurface = EGL_NO_SURFACE;
+        ssd->backing_borrow = NULL;
+        ssd->backing_id = -1;
+#endif
     }
 #endif
     ssd->dcl.con = con;
diff -ru --un qemu-7.2.0/ui/vnc.c qemu-utm-7.2.0/ui/vnc.c
--- qemu-7.2.0/ui/vnc.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/ui/vnc.c	2022-12-26 13:45:04
@@ -1882,16 +1882,22 @@
 static void do_key_event(VncState *vs, int down, int keycode, int sym)
 {
     QKeyCode qcode = qemu_input_key_number_to_qcode(keycode);
+    QemuConsole *con = vs->vd->dcl.con;
 
     /* QEMU console switch */
     switch (qcode) {
     case Q_KEY_CODE_1 ... Q_KEY_CODE_9: /* '1' to '9' keys */
-        if (vs->vd->dcl.con == NULL && down &&
+        if (down &&
             qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CTRL) &&
             qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_ALT)) {
-            /* Reset the modifiers sent to the current console */
-            qkbd_state_lift_all_keys(vs->vd->kbd);
-            console_select(qcode - Q_KEY_CODE_1);
+            QemuConsole *con = qemu_console_lookup_by_index(qcode - Q_KEY_CODE_1);
+            if (con) {
+                /* Reset the modifiers sent to the current console */
+                qkbd_state_lift_all_keys(vs->vd->kbd);
+                unregister_displaychangelistener(&vs->vd->dcl);
+                vs->vd->dcl.con = con;
+                register_displaychangelistener(&vs->vd->dcl);
+            }
             return;
         }
     default:
@@ -1945,7 +1951,7 @@
     }
 
     qkbd_state_key_event(vs->vd->kbd, qcode, down);
-    if (!qemu_console_is_graphic(NULL)) {
+    if (!qemu_console_is_graphic(con)) {
         bool numlock = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_NUMLOCK);
         bool control = qkbd_state_modifier_get(vs->vd->kbd, QKBD_MOD_CTRL);
         /* QEMU console emulation */
@@ -1959,88 +1965,88 @@
             case 0xb8:                          /* Right ALT */
                 break;
             case 0xc8:
-                kbd_put_keysym(QEMU_KEY_UP);
+                kbd_put_keysym_console(con, QEMU_KEY_UP);
                 break;
             case 0xd0:
-                kbd_put_keysym(QEMU_KEY_DOWN);
+                kbd_put_keysym_console(con, QEMU_KEY_DOWN);
                 break;
             case 0xcb:
-                kbd_put_keysym(QEMU_KEY_LEFT);
+                kbd_put_keysym_console(con, QEMU_KEY_LEFT);
                 break;
             case 0xcd:
-                kbd_put_keysym(QEMU_KEY_RIGHT);
+                kbd_put_keysym_console(con, QEMU_KEY_RIGHT);
                 break;
             case 0xd3:
-                kbd_put_keysym(QEMU_KEY_DELETE);
+                kbd_put_keysym_console(con, QEMU_KEY_DELETE);
                 break;
             case 0xc7:
-                kbd_put_keysym(QEMU_KEY_HOME);
+                kbd_put_keysym_console(con, QEMU_KEY_HOME);
                 break;
             case 0xcf:
-                kbd_put_keysym(QEMU_KEY_END);
+                kbd_put_keysym_console(con, QEMU_KEY_END);
                 break;
             case 0xc9:
-                kbd_put_keysym(QEMU_KEY_PAGEUP);
+                kbd_put_keysym_console(con, QEMU_KEY_PAGEUP);
                 break;
             case 0xd1:
-                kbd_put_keysym(QEMU_KEY_PAGEDOWN);
+                kbd_put_keysym_console(con, QEMU_KEY_PAGEDOWN);
                 break;
 
             case 0x47:
-                kbd_put_keysym(numlock ? '7' : QEMU_KEY_HOME);
+                kbd_put_keysym_console(con, numlock ? '7' : QEMU_KEY_HOME);
                 break;
             case 0x48:
-                kbd_put_keysym(numlock ? '8' : QEMU_KEY_UP);
+                kbd_put_keysym_console(con, numlock ? '8' : QEMU_KEY_UP);
                 break;
             case 0x49:
-                kbd_put_keysym(numlock ? '9' : QEMU_KEY_PAGEUP);
+                kbd_put_keysym_console(con, numlock ? '9' : QEMU_KEY_PAGEUP);
                 break;
             case 0x4b:
-                kbd_put_keysym(numlock ? '4' : QEMU_KEY_LEFT);
+                kbd_put_keysym_console(con, numlock ? '4' : QEMU_KEY_LEFT);
                 break;
             case 0x4c:
-                kbd_put_keysym('5');
+                kbd_put_keysym_console(con, '5');
                 break;
             case 0x4d:
-                kbd_put_keysym(numlock ? '6' : QEMU_KEY_RIGHT);
+                kbd_put_keysym_console(con, numlock ? '6' : QEMU_KEY_RIGHT);
                 break;
             case 0x4f:
-                kbd_put_keysym(numlock ? '1' : QEMU_KEY_END);
+                kbd_put_keysym_console(con, numlock ? '1' : QEMU_KEY_END);
                 break;
             case 0x50:
-                kbd_put_keysym(numlock ? '2' : QEMU_KEY_DOWN);
+                kbd_put_keysym_console(con, numlock ? '2' : QEMU_KEY_DOWN);
                 break;
             case 0x51:
-                kbd_put_keysym(numlock ? '3' : QEMU_KEY_PAGEDOWN);
+                kbd_put_keysym_console(con, numlock ? '3' : QEMU_KEY_PAGEDOWN);
                 break;
             case 0x52:
-                kbd_put_keysym('0');
+                kbd_put_keysym_console(con, '0');
                 break;
             case 0x53:
-                kbd_put_keysym(numlock ? '.' : QEMU_KEY_DELETE);
+                kbd_put_keysym_console(con, numlock ? '.' : QEMU_KEY_DELETE);
                 break;
 
             case 0xb5:
-                kbd_put_keysym('/');
+                kbd_put_keysym_console(con, '/');
                 break;
             case 0x37:
-                kbd_put_keysym('*');
+                kbd_put_keysym_console(con, '*');
                 break;
             case 0x4a:
-                kbd_put_keysym('-');
+                kbd_put_keysym_console(con, '-');
                 break;
             case 0x4e:
-                kbd_put_keysym('+');
+                kbd_put_keysym_console(con, '+');
                 break;
             case 0x9c:
-                kbd_put_keysym('\n');
+                kbd_put_keysym_console(con, '\n');
                 break;
 
             default:
                 if (control) {
-                    kbd_put_keysym(sym & 0x1f);
+                    kbd_put_keysym_console(con, sym & 0x1f);
                 } else {
-                    kbd_put_keysym(sym);
+                    kbd_put_keysym_console(con, sym);
                 }
                 break;
             }
@@ -2058,7 +2064,7 @@
     int keycode;
     int lsym = sym;
 
-    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(NULL)) {
+    if (lsym >= 'A' && lsym <= 'Z' && qemu_console_is_graphic(vs->vd->dcl.con)) {
         lsym = lsym - 'A' + 'a';
     }
 
@@ -4204,7 +4210,7 @@
             goto fail;
         }
     } else {
-        con = NULL;
+        con = qemu_console_lookup_first_graphic_console();
     }
 
     if (con != vd->dcl.con) {
diff -ru --un qemu-7.2.0/util/coroutine-ucontext.c qemu-utm-7.2.0/util/coroutine-ucontext.c
--- qemu-7.2.0/util/coroutine-ucontext.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/util/coroutine-ucontext.c	2022-12-26 13:45:04
@@ -23,7 +23,16 @@
 #undef _FORTIFY_SOURCE
 #endif
 #include "qemu/osdep.h"
+#if defined(CONFIG_LIBUCONTEXT)
+#include <libucontext/libucontext.h>
+#define ucontext_t libucontext_ucontext_t
+#define getcontext libucontext_getcontext
+#define setcontext libucontext_setcontext
+#define swapcontext libucontext_swapcontext
+#define makecontext libucontext_makecontext
+#else
 #include <ucontext.h>
+#endif
 #include "qemu/coroutine_int.h"
 #include "qemu/coroutine-tls.h"
 
diff -ru --un qemu-7.2.0/util/osdep.c qemu-utm-7.2.0/util/osdep.c
--- qemu-7.2.0/util/osdep.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/util/osdep.c	2022-12-26 13:45:04
@@ -31,6 +31,10 @@
 #include "qemu/hw-version.h"
 #include "monitor/monitor.h"
 
+#ifdef CONFIG_DARWIN
+#include "tcg/tcg-apple-jit.h"
+#endif
+
 static const char *hw_version = QEMU_HW_VERSION;
 
 int socket_set_cork(int fd, int v)
diff -ru --un qemu-7.2.0/util/rcu.c qemu-utm-7.2.0/util/rcu.c
--- qemu-7.2.0/util/rcu.c	2022-12-14 11:28:45
+++ qemu-utm-7.2.0/util/rcu.c	2022-12-26 13:45:04
@@ -398,7 +398,10 @@
     qemu_thread_create(&thread, "call_rcu", call_rcu_thread,
                        NULL, QEMU_THREAD_DETACHED);
 
+    /* TLS not available in shared library */
+#ifndef CONFIG_SHARED_LIBRARY_BUILD
     rcu_register_thread();
+#endif
 }
 
 static int atfork_depth = 1;
